{"ast":null,"code":"import mqtt from 'mqtt';\nimport { protobufService } from './protobufService';\nclass MQTTService {\n  constructor() {\n    this.client = null;\n    this.config = null;\n    this.sensorData = {};\n    this.listeners = [];\n  }\n  async connect(config) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        // Initialize protobuf service first\n        await protobufService.initialize();\n        this.config = config;\n\n        // Use WebSocket protocol for browser compatibility\n        const url = `ws://${config.host}:8083`;\n        this.client = mqtt.connect(url, {\n          clientId: config.client_id,\n          clean: true,\n          connectTimeout: 4000,\n          reconnectPeriod: 1000\n        });\n        this.client.on('connect', () => {\n          console.log('MQTT Connected');\n          this.subscribeToTopics();\n          resolve();\n        });\n        this.client.on('message', (topic, message) => {\n          this.handleMessage(topic, message);\n        });\n        this.client.on('error', error => {\n          console.error('MQTT Error:', error);\n          reject(error);\n        });\n        this.client.on('close', () => {\n          console.log('MQTT Connection closed');\n        });\n      } catch (error) {\n        console.error('Failed to initialize MQTT with protobuf:', error);\n        reject(error);\n      }\n    });\n  }\n  subscribeToTopics() {\n    if (!this.client || !this.config) return;\n    console.log('Starting to subscribe to topics...');\n    console.log('Available topics:', Object.keys(this.config.topics));\n    Object.entries(this.config.topics).forEach(([key, topicConfig]) => {\n      console.log(`Attempting to subscribe to: ${topicConfig.topic}`);\n      this.client.subscribe(topicConfig.topic, err => {\n        if (err) {\n          console.error(`Error subscribing to ${topicConfig.topic}:`, err);\n        } else {\n          console.log(`✅ Successfully subscribed to ${topicConfig.topic}`);\n        }\n      });\n    });\n  }\n  handleMessage(topic, message) {\n    var _jsonData$temperature, _jsonData$heading, _jsonData$latitude, _jsonData$longitude;\n    if (!this.config) return;\n    console.log(`MQTT Message received - Topic: ${topic}, Message length: ${message.length} bytes`);\n\n    // Find the sensor key for this topic\n    const sensorKey = Object.keys(this.config.topics).find(key => this.config.topics[key].topic === topic);\n    if (sensorKey) {\n      const topicConfig = this.config.topics[sensorKey];\n      try {\n        // Try to parse as protobuf first\n        const parsedData = protobufService.parseMessage(topic, message);\n        if (parsedData) {\n          // Format the parsed protobuf data for display\n          const formattedData = protobufService.formatSensorData(topic, parsedData);\n          const sensorData = {\n            value: formattedData.value,\n            description: formattedData.description,\n            unit: formattedData.unit,\n            timestamp: formattedData.timestamp\n          };\n          this.sensorData[sensorKey] = sensorData;\n          console.log(`📦 Protobuf sensor data updated for ${sensorKey}:`, sensorData);\n          this.notifyListeners();\n        } else {\n          // Fallback to JSON parsing if protobuf fails\n          const messageStr = message.toString();\n          console.log(`🔄 Falling back to JSON parsing for ${topic}`);\n          try {\n            const jsonData = JSON.parse(messageStr);\n\n            // Extract value based on topic type\n            let parsedValue;\n            let timestamp = new Date().toISOString();\n            switch (sensorKey) {\n              case 'temperature':\n                parsedValue = ((_jsonData$temperature = jsonData.temperature) === null || _jsonData$temperature === void 0 ? void 0 : _jsonData$temperature.toString()) || 'N/A';\n                timestamp = jsonData.timestamp || timestamp;\n                break;\n              case 'compass':\n                parsedValue = ((_jsonData$heading = jsonData.heading) === null || _jsonData$heading === void 0 ? void 0 : _jsonData$heading.toString()) || 'N/A';\n                timestamp = jsonData.timestamp || timestamp;\n                break;\n              case 'gps':\n                parsedValue = `${((_jsonData$latitude = jsonData.latitude) === null || _jsonData$latitude === void 0 ? void 0 : _jsonData$latitude.toFixed(6)) || 'N/A'}, ${((_jsonData$longitude = jsonData.longitude) === null || _jsonData$longitude === void 0 ? void 0 : _jsonData$longitude.toFixed(6)) || 'N/A'}`;\n                timestamp = jsonData.timestamp || timestamp;\n                break;\n              case 'status':\n                parsedValue = jsonData.toString();\n                break;\n              default:\n                parsedValue = messageStr;\n            }\n            const sensorData = {\n              value: parsedValue,\n              description: topicConfig.description,\n              unit: topicConfig.unit,\n              timestamp: timestamp\n            };\n            this.sensorData[sensorKey] = sensorData;\n            console.log(`📄 JSON sensor data updated for ${sensorKey}:`, sensorData);\n            this.notifyListeners();\n          } catch (jsonError) {\n            console.error(`❌ Failed to parse message for ${topic}:`, jsonError);\n          }\n        }\n      } catch (error) {\n        console.error(`❌ Failed to handle message for ${topic}:`, error);\n      }\n    } else {\n      console.log(`Received message for unknown topic: ${topic}`);\n    }\n  }\n  notifyListeners() {\n    this.listeners.forEach(listener => listener({\n      ...this.sensorData\n    }));\n  }\n  onSensorDataUpdate(callback) {\n    this.listeners.push(callback);\n  }\n  getSensorData() {\n    return {\n      ...this.sensorData\n    };\n  }\n  disconnect() {\n    if (this.client) {\n      this.client.end();\n      this.client = null;\n    }\n  }\n  isConnected() {\n    var _this$client;\n    return ((_this$client = this.client) === null || _this$client === void 0 ? void 0 : _this$client.connected) || false;\n  }\n}\nexport const mqttService = new MQTTService();","map":{"version":3,"names":["mqtt","protobufService","MQTTService","constructor","client","config","sensorData","listeners","connect","Promise","resolve","reject","initialize","url","host","clientId","client_id","clean","connectTimeout","reconnectPeriod","on","console","log","subscribeToTopics","topic","message","handleMessage","error","Object","keys","topics","entries","forEach","key","topicConfig","subscribe","err","_jsonData$temperature","_jsonData$heading","_jsonData$latitude","_jsonData$longitude","length","sensorKey","find","parsedData","parseMessage","formattedData","formatSensorData","value","description","unit","timestamp","notifyListeners","messageStr","toString","jsonData","JSON","parse","parsedValue","Date","toISOString","temperature","heading","latitude","toFixed","longitude","jsonError","listener","onSensorDataUpdate","callback","push","getSensorData","disconnect","end","isConnected","_this$client","connected","mqttService"],"sources":["/home/linux-1/projects/web-server-app/imx8mp-web-client/src/services/mqttService.ts"],"sourcesContent":["import mqtt, { MqttClient } from 'mqtt';\nimport { SensorData, MQTTConfig } from '../types';\nimport { protobufService } from './protobufService';\n\nclass MQTTService {\n  private client: MqttClient | null = null;\n  private config: MQTTConfig | null = null;\n  private sensorData: { [key: string]: SensorData } = {};\n  private listeners: ((data: { [key: string]: SensorData }) => void)[] = [];\n\n  async connect(config: MQTTConfig): Promise<void> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        // Initialize protobuf service first\n        await protobufService.initialize();\n        \n        this.config = config;\n        \n        // Use WebSocket protocol for browser compatibility\n        const url = `ws://${config.host}:8083`;\n        \n        this.client = mqtt.connect(url, {\n          clientId: config.client_id,\n          clean: true,\n          connectTimeout: 4000,\n          reconnectPeriod: 1000,\n        });\n\n        this.client.on('connect', () => {\n          console.log('MQTT Connected');\n          this.subscribeToTopics();\n          resolve();\n        });\n\n        this.client.on('message', (topic, message) => {\n          this.handleMessage(topic, message);\n        });\n\n        this.client.on('error', (error) => {\n          console.error('MQTT Error:', error);\n          reject(error);\n        });\n\n        this.client.on('close', () => {\n          console.log('MQTT Connection closed');\n        });\n      } catch (error) {\n        console.error('Failed to initialize MQTT with protobuf:', error);\n        reject(error);\n      }\n    });\n  }\n\n  private subscribeToTopics(): void {\n    if (!this.client || !this.config) return;\n\n    console.log('Starting to subscribe to topics...');\n    console.log('Available topics:', Object.keys(this.config.topics));\n\n    Object.entries(this.config.topics).forEach(([key, topicConfig]) => {\n      console.log(`Attempting to subscribe to: ${topicConfig.topic}`);\n      this.client!.subscribe(topicConfig.topic, (err) => {\n        if (err) {\n          console.error(`Error subscribing to ${topicConfig.topic}:`, err);\n        } else {\n          console.log(`✅ Successfully subscribed to ${topicConfig.topic}`);\n        }\n      });\n    });\n  }\n\n  private handleMessage(topic: string, message: Buffer): void {\n    if (!this.config) return;\n\n    console.log(`MQTT Message received - Topic: ${topic}, Message length: ${message.length} bytes`);\n\n    // Find the sensor key for this topic\n    const sensorKey = Object.keys(this.config.topics).find(\n      key => this.config!.topics[key].topic === topic\n    );\n\n    if (sensorKey) {\n      const topicConfig = this.config.topics[sensorKey];\n      \n      try {\n        // Try to parse as protobuf first\n        const parsedData = protobufService.parseMessage(topic, message);\n        \n        if (parsedData) {\n          // Format the parsed protobuf data for display\n          const formattedData = protobufService.formatSensorData(topic, parsedData);\n          \n          const sensorData: SensorData = {\n            value: formattedData.value,\n            description: formattedData.description,\n            unit: formattedData.unit,\n            timestamp: formattedData.timestamp,\n          };\n\n          this.sensorData[sensorKey] = sensorData;\n          console.log(`📦 Protobuf sensor data updated for ${sensorKey}:`, sensorData);\n          this.notifyListeners();\n        } else {\n          // Fallback to JSON parsing if protobuf fails\n          const messageStr = message.toString();\n          console.log(`🔄 Falling back to JSON parsing for ${topic}`);\n          \n          try {\n            const jsonData = JSON.parse(messageStr);\n            \n            // Extract value based on topic type\n            let parsedValue: string;\n            let timestamp: string = new Date().toISOString();\n            \n            switch (sensorKey) {\n              case 'temperature':\n                parsedValue = jsonData.temperature?.toString() || 'N/A';\n                timestamp = jsonData.timestamp || timestamp;\n                break;\n              case 'compass':\n                parsedValue = jsonData.heading?.toString() || 'N/A';\n                timestamp = jsonData.timestamp || timestamp;\n                break;\n              case 'gps':\n                parsedValue = `${jsonData.latitude?.toFixed(6) || 'N/A'}, ${jsonData.longitude?.toFixed(6) || 'N/A'}`;\n                timestamp = jsonData.timestamp || timestamp;\n                break;\n              case 'status':\n                parsedValue = jsonData.toString();\n                break;\n              default:\n                parsedValue = messageStr;\n            }\n\n            const sensorData: SensorData = {\n              value: parsedValue,\n              description: topicConfig.description,\n              unit: topicConfig.unit,\n              timestamp: timestamp,\n            };\n\n            this.sensorData[sensorKey] = sensorData;\n            console.log(`📄 JSON sensor data updated for ${sensorKey}:`, sensorData);\n            this.notifyListeners();\n          } catch (jsonError) {\n            console.error(`❌ Failed to parse message for ${topic}:`, jsonError);\n          }\n        }\n      } catch (error) {\n        console.error(`❌ Failed to handle message for ${topic}:`, error);\n      }\n    } else {\n      console.log(`Received message for unknown topic: ${topic}`);\n    }\n  }\n\n  private notifyListeners(): void {\n    this.listeners.forEach(listener => listener({ ...this.sensorData }));\n  }\n\n  onSensorDataUpdate(callback: (data: { [key: string]: SensorData }) => void): void {\n    this.listeners.push(callback);\n  }\n\n  getSensorData(): { [key: string]: SensorData } {\n    return { ...this.sensorData };\n  }\n\n  disconnect(): void {\n    if (this.client) {\n      this.client.end();\n      this.client = null;\n    }\n  }\n\n  isConnected(): boolean {\n    return this.client?.connected || false;\n  }\n}\n\nexport const mqttService = new MQTTService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}