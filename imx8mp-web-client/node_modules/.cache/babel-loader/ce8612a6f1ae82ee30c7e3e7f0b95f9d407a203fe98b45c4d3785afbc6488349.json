{"ast":null,"code":"import mqtt from 'mqtt';\nimport { protobufService } from './protobufService';\n\n// Import the generated protobuf types\n\nclass MQTTService {\n  constructor() {\n    this.client = null;\n    this.config = null;\n    this.sensorData = {};\n    this.listeners = [];\n    this.fileUploadResultListener = null;\n  }\n  async connect(config) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        await protobufService.initialize();\n        this.config = config;\n        const url = `ws://${config.host}:8083`;\n        this.client = mqtt.connect(url, {\n          clientId: config.client_id,\n          clean: true,\n          connectTimeout: 4000,\n          reconnectPeriod: 1000\n        });\n        this.client.on('connect', () => {\n          this.subscribeToTopics();\n          resolve();\n        });\n        this.client.on('message', (topic, message) => {\n          this.handleMessage(topic, message);\n        });\n        this.client.on('error', error => {\n          reject(error);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  subscribeToTopics() {\n    if (!this.client || !this.config) return;\n    Object.entries(this.config.topics).forEach(([key, topicConfig]) => {\n      this.client.subscribe(topicConfig.topic);\n    });\n  }\n  handleMessage(topic, message) {\n    // Handle sensor topics as before...\n    // Handle file upload result topic\n    if (topic === 'uploads/success' && this.fileUploadResultListener) {\n      try {\n        const FileUploadResult = protobufService.getFileUploadResultType();\n        const result = FileUploadResult.decode(message);\n        this.fileUploadResultListener(result);\n      } catch (e) {\n        console.error('Failed to decode FileUploadResult:', e);\n      }\n    }\n  }\n\n  // --- File Upload via MQTT ---\n  async uploadFileViaMQTT(file, uploadDirectory, allowedExtensions, publishTopic, returnTopic) {\n    if (!this.client) throw new Error('MQTT client not connected');\n    const extension = file.name.substring(file.name.lastIndexOf('.'));\n    if (!allowedExtensions.includes(extension)) {\n      throw new Error('File extension not allowed');\n    }\n    const arrayBuffer = await file.arrayBuffer();\n    const FileUploadRequest = protobufService.getFileUploadRequestType();\n    const payload = FileUploadRequest.encode({\n      filename: file.name,\n      extension,\n      file_data: new Uint8Array(arrayBuffer),\n      upload_directory: uploadDirectory\n    }).finish();\n    // Publish the file upload request\n    this.client.publish(publishTopic, payload);\n    // Optionally subscribe to return topic and wait for result\n    if (returnTopic) {\n      return new Promise((resolve, reject) => {\n        this.fileUploadResultListener = result => {\n          this.client.unsubscribe(returnTopic);\n          this.fileUploadResultListener = null;\n          resolve(result);\n        };\n        this.client.subscribe(returnTopic);\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n  onSensorDataUpdate(callback) {\n    this.listeners.push(callback);\n  }\n  getSensorData() {\n    return {\n      ...this.sensorData\n    };\n  }\n  disconnect() {\n    if (this.client) {\n      this.client.end();\n      this.client = null;\n    }\n  }\n  isConnected() {\n    var _this$client;\n    return ((_this$client = this.client) === null || _this$client === void 0 ? void 0 : _this$client.connected) || false;\n  }\n\n  // Protobuf helpers\n  getFileUploadRequestType() {\n    return protobufService.getFileUploadRequestType();\n  }\n  getFileUploadResultType() {\n    return protobufService.getFileUploadResultType();\n  }\n}\nexport const mqttService = new MQTTService();","map":{"version":3,"names":["mqtt","protobufService","MQTTService","constructor","client","config","sensorData","listeners","fileUploadResultListener","connect","Promise","resolve","reject","initialize","url","host","clientId","client_id","clean","connectTimeout","reconnectPeriod","on","subscribeToTopics","topic","message","handleMessage","error","Object","entries","topics","forEach","key","topicConfig","subscribe","FileUploadResult","getFileUploadResultType","result","decode","e","console","uploadFileViaMQTT","file","uploadDirectory","allowedExtensions","publishTopic","returnTopic","Error","extension","name","substring","lastIndexOf","includes","arrayBuffer","FileUploadRequest","getFileUploadRequestType","payload","encode","filename","file_data","Uint8Array","upload_directory","finish","publish","unsubscribe","onSensorDataUpdate","callback","push","getSensorData","disconnect","end","isConnected","_this$client","connected","mqttService"],"sources":["/home/linux-1/projects/web-server-app/imx8mp-web-client/src/services/mqttService.ts"],"sourcesContent":["import mqtt, { MqttClient } from 'mqtt';\nimport { SensorData, MQTTConfig } from '../types';\nimport { protobufService } from './protobufService';\n\n// Import the generated protobuf types\nimport * as fileops from '../../proto/fileops.proto';\n\nclass MQTTService {\n  private client: MqttClient | null = null;\n  private config: MQTTConfig | null = null;\n  private sensorData: { [key: string]: SensorData } = {};\n  private listeners: ((data: { [key: string]: SensorData }) => void)[] = [];\n  private fileUploadResultListener: ((result: any) => void) | null = null;\n\n  async connect(config: MQTTConfig): Promise<void> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        await protobufService.initialize();\n        this.config = config;\n        const url = `ws://${config.host}:8083`;\n        this.client = mqtt.connect(url, {\n          clientId: config.client_id,\n          clean: true,\n          connectTimeout: 4000,\n          reconnectPeriod: 1000,\n        });\n        this.client.on('connect', () => {\n          this.subscribeToTopics();\n          resolve();\n        });\n        this.client.on('message', (topic, message) => {\n          this.handleMessage(topic, message);\n        });\n        this.client.on('error', (error) => {\n          reject(error);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  private subscribeToTopics(): void {\n    if (!this.client || !this.config) return;\n    Object.entries(this.config.topics).forEach(([key, topicConfig]) => {\n      this.client!.subscribe(topicConfig.topic);\n    });\n  }\n\n  private handleMessage(topic: string, message: Buffer): void {\n    // Handle sensor topics as before...\n    // Handle file upload result topic\n    if (topic === 'uploads/success' && this.fileUploadResultListener) {\n      try {\n        const FileUploadResult = protobufService.getFileUploadResultType();\n        const result = FileUploadResult.decode(message);\n        this.fileUploadResultListener(result);\n      } catch (e) {\n        console.error('Failed to decode FileUploadResult:', e);\n      }\n    }\n  }\n\n  // --- File Upload via MQTT ---\n  async uploadFileViaMQTT(file: File, uploadDirectory: string, allowedExtensions: string[], publishTopic: string, returnTopic?: string): Promise<any> {\n    if (!this.client) throw new Error('MQTT client not connected');\n    const extension = file.name.substring(file.name.lastIndexOf('.'));\n    if (!allowedExtensions.includes(extension)) {\n      throw new Error('File extension not allowed');\n    }\n    const arrayBuffer = await file.arrayBuffer();\n    const FileUploadRequest = protobufService.getFileUploadRequestType();\n    const payload = FileUploadRequest.encode({\n      filename: file.name,\n      extension,\n      file_data: new Uint8Array(arrayBuffer),\n      upload_directory: uploadDirectory,\n    }).finish();\n    // Publish the file upload request\n    this.client.publish(publishTopic, payload);\n    // Optionally subscribe to return topic and wait for result\n    if (returnTopic) {\n      return new Promise((resolve, reject) => {\n        this.fileUploadResultListener = (result) => {\n          this.client!.unsubscribe(returnTopic);\n          this.fileUploadResultListener = null;\n          resolve(result);\n        };\n        this.client!.subscribe(returnTopic);\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  onSensorDataUpdate(callback: (data: { [key: string]: SensorData }) => void): void {\n    this.listeners.push(callback);\n  }\n\n  getSensorData(): { [key: string]: SensorData } {\n    return { ...this.sensorData };\n  }\n\n  disconnect(): void {\n    if (this.client) {\n      this.client.end();\n      this.client = null;\n    }\n  }\n\n  isConnected(): boolean {\n    return this.client?.connected || false;\n  }\n\n  // Protobuf helpers\n  getFileUploadRequestType() {\n    return protobufService.getFileUploadRequestType();\n  }\n  getFileUploadResultType() {\n    return protobufService.getFileUploadResultType();\n  }\n}\n\nexport const mqttService = new MQTTService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}