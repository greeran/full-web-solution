{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Namespace;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\nvar Field = require(\"./field\"),\n  util = require(\"./util\"),\n  OneOf = require(\"./oneof\");\nvar Type,\n  // cyclic\n  Service, Enum;\n\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */\nNamespace.fromJSON = function fromJSON(name, json) {\n  return new Namespace(name, json.options).addJSON(json.nested);\n};\n\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */\nfunction arrayToJSON(array, toJSONOptions) {\n  if (!(array && array.length)) return undefined;\n  var obj = {};\n  for (var i = 0; i < array.length; ++i) obj[array[i].name] = array[i].toJSON(toJSONOptions);\n  return obj;\n}\nNamespace.arrayToJSON = arrayToJSON;\n\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedId = function isReservedId(reserved, id) {\n  if (reserved) for (var i = 0; i < reserved.length; ++i) if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id) return true;\n  return false;\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedName = function isReservedName(reserved, name) {\n  if (reserved) for (var i = 0; i < reserved.length; ++i) if (reserved[i] === name) return true;\n  return false;\n};\n\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */\nfunction Namespace(name, options) {\n  ReflectionObject.call(this, name, options);\n\n  /**\n   * Nested objects by name.\n   * @type {Object.<string,ReflectionObject>|undefined}\n   */\n  this.nested = undefined; // toJSON\n\n  /**\n   * Cached nested objects as an array.\n   * @type {ReflectionObject[]|null}\n   * @private\n   */\n  this._nestedArray = null;\n\n  /**\n   * Cache lookup calls for any objects contains anywhere under this namespace.\n   * This drastically speeds up resolve for large cross-linked protos where the same\n   * types are looked up repeatedly.\n   * @type {Object.<string,ReflectionObject|null>}\n   * @private\n   */\n  this._lookupCache = {};\n\n  /**\n   * Whether or not objects contained in this namespace need feature resolution.\n   * @type {boolean}\n   * @protected\n   */\n  this._needsRecursiveFeatureResolution = true;\n\n  /**\n   * Whether or not objects contained in this namespace need a resolve.\n   * @type {boolean}\n   * @protected\n   */\n  this._needsRecursiveResolve = true;\n}\nfunction clearCache(namespace) {\n  namespace._nestedArray = null;\n  namespace._lookupCache = {};\n\n  // Also clear parent caches, since they include nested lookups.\n  var parent = namespace;\n  while (parent = parent.parent) {\n    parent._lookupCache = {};\n  }\n  return namespace;\n}\n\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n  get: function () {\n    return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n  }\n});\n\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */\n\n/**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */\n\n/**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\n */\n\n/**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n  return util.toObject([\"options\", this.options, \"nested\", arrayToJSON(this.nestedArray, toJSONOptions)]);\n};\n\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n  var ns = this;\n  /* istanbul ignore else */\n  if (nestedJson) {\n    for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n      nested = nestedJson[names[i]];\n      ns.add(\n      // most to least likely\n      (nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));\n    }\n  }\n  return this;\n};\n\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */\nNamespace.prototype.get = function get(name) {\n  return this.nested && this.nested[name] || null;\n};\n\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */\nNamespace.prototype.getEnum = function getEnum(name) {\n  if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;\n  throw Error(\"no such enum: \" + name);\n};\n\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */\nNamespace.prototype.add = function add(object) {\n  if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError(\"object must be a valid nested object\");\n  if (!this.nested) this.nested = {};else {\n    var prev = this.get(object.name);\n    if (prev) {\n      if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n        // replace plain namespace but keep existing nested elements and options\n        var nested = prev.nestedArray;\n        for (var i = 0; i < nested.length; ++i) object.add(nested[i]);\n        this.remove(prev);\n        if (!this.nested) this.nested = {};\n        object.setOptions(prev.options, true);\n      } else throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    }\n  }\n  this.nested[object.name] = object;\n  if (!(this instanceof Type || this instanceof Service || this instanceof Enum || this instanceof Field)) {\n    // This is a package or a root namespace.\n    if (!object._edition) {\n      // Make sure that some edition is set if it hasn't already been specified.\n      object._edition = object._defaultEdition;\n    }\n  }\n  this._needsRecursiveFeatureResolution = true;\n  this._needsRecursiveResolve = true;\n\n  // Also clear parent caches, since they need to recurse down.\n  var parent = this;\n  while (parent = parent.parent) {\n    parent._needsRecursiveFeatureResolution = true;\n    parent._needsRecursiveResolve = true;\n  }\n  object.onAdd(this);\n  return clearCache(this);\n};\n\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */\nNamespace.prototype.remove = function remove(object) {\n  if (!(object instanceof ReflectionObject)) throw TypeError(\"object must be a ReflectionObject\");\n  if (object.parent !== this) throw Error(object + \" is not a member of \" + this);\n  delete this.nested[object.name];\n  if (!Object.keys(this.nested).length) this.nested = undefined;\n  object.onRemove(this);\n  return clearCache(this);\n};\n\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */\nNamespace.prototype.define = function define(path, json) {\n  if (util.isString(path)) path = path.split(\".\");else if (!Array.isArray(path)) throw TypeError(\"illegal path\");\n  if (path && path.length && path[0] === \"\") throw Error(\"path must be relative\");\n  var ptr = this;\n  while (path.length > 0) {\n    var part = path.shift();\n    if (ptr.nested && ptr.nested[part]) {\n      ptr = ptr.nested[part];\n      if (!(ptr instanceof Namespace)) throw Error(\"path conflicts with non-namespace objects\");\n    } else ptr.add(ptr = new Namespace(part));\n  }\n  if (json) ptr.addJSON(json);\n  return ptr;\n};\n\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */\nNamespace.prototype.resolveAll = function resolveAll() {\n  if (!this._needsRecursiveResolve) return this;\n  this._resolveFeaturesRecursive(this._edition);\n  var nested = this.nestedArray,\n    i = 0;\n  this.resolve();\n  while (i < nested.length) if (nested[i] instanceof Namespace) nested[i++].resolveAll();else nested[i++].resolve();\n  this._needsRecursiveResolve = false;\n  return this;\n};\n\n/**\n * @override\n */\nNamespace.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n  if (!this._needsRecursiveFeatureResolution) return this;\n  this._needsRecursiveFeatureResolution = false;\n  edition = this._edition || edition;\n  ReflectionObject.prototype._resolveFeaturesRecursive.call(this, edition);\n  this.nestedArray.forEach(nested => {\n    nested._resolveFeaturesRecursive(edition);\n  });\n  return this;\n};\n\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n  /* istanbul ignore next */\n  if (typeof filterTypes === \"boolean\") {\n    parentAlreadyChecked = filterTypes;\n    filterTypes = undefined;\n  } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [filterTypes];\n  if (util.isString(path) && path.length) {\n    if (path === \".\") return this.root;\n    path = path.split(\".\");\n  } else if (!path.length) return this;\n  var flatPath = path.join(\".\");\n\n  // Start at root if path is absolute\n  if (path[0] === \"\") return this.root.lookup(path.slice(1), filterTypes);\n\n  // Early bailout for objects with matching absolute paths\n  var found = this.root._fullyQualifiedObjects && this.root._fullyQualifiedObjects[\".\" + flatPath];\n  if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n    return found;\n  }\n\n  // Do a regular lookup at this namespace and below\n  found = this._lookupImpl(path, flatPath);\n  if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n    return found;\n  }\n  if (parentAlreadyChecked) return null;\n\n  // If there hasn't been a match, walk up the tree and look more broadly\n  var current = this;\n  while (current.parent) {\n    found = current.parent._lookupImpl(path, flatPath);\n    if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n      return found;\n    }\n    current = current.parent;\n  }\n  return null;\n};\n\n/**\n * Internal helper for lookup that handles searching just at this namespace and below along with caching.\n * @param {string[]} path Path to look up\n * @param {string} flatPath Flattened version of the path to use as a cache key\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @private\n */\nNamespace.prototype._lookupImpl = function lookup(path, flatPath) {\n  if (Object.prototype.hasOwnProperty.call(this._lookupCache, flatPath)) {\n    return this._lookupCache[flatPath];\n  }\n\n  // Test if the first part matches any nested object, and if so, traverse if path contains more\n  var found = this.get(path[0]);\n  var exact = null;\n  if (found) {\n    if (path.length === 1) {\n      exact = found;\n    } else if (found instanceof Namespace) {\n      path = path.slice(1);\n      exact = found._lookupImpl(path, path.join(\".\"));\n    }\n\n    // Otherwise try each nested namespace\n  } else {\n    for (var i = 0; i < this.nestedArray.length; ++i) if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i]._lookupImpl(path, flatPath))) exact = found;\n  }\n\n  // Set this even when null, so that when we walk up the tree we can quickly bail on repeated checks back down.\n  this._lookupCache[flatPath] = exact;\n  return exact;\n};\n\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */\nNamespace.prototype.lookupType = function lookupType(path) {\n  var found = this.lookup(path, [Type]);\n  if (!found) throw Error(\"no such type: \" + path);\n  return found;\n};\n\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n  var found = this.lookup(path, [Enum]);\n  if (!found) throw Error(\"no such Enum '\" + path + \"' in \" + this);\n  return found;\n};\n\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n  var found = this.lookup(path, [Type, Enum]);\n  if (!found) throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n  return found;\n};\n\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */\nNamespace.prototype.lookupService = function lookupService(path) {\n  var found = this.lookup(path, [Service]);\n  if (!found) throw Error(\"no such Service '\" + path + \"' in \" + this);\n  return found;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function (Type_, Service_, Enum_) {\n  Type = Type_;\n  Service = Service_;\n  Enum = Enum_;\n};","map":{"version":3,"names":["module","exports","Namespace","ReflectionObject","require","prototype","Object","create","constructor","className","Field","util","OneOf","Type","Service","Enum","fromJSON","name","json","options","addJSON","nested","arrayToJSON","array","toJSONOptions","length","undefined","obj","i","toJSON","isReservedId","reserved","id","isReservedName","call","_nestedArray","_lookupCache","_needsRecursiveFeatureResolution","_needsRecursiveResolve","clearCache","namespace","parent","defineProperty","get","toArray","toObject","nestedArray","nestedJson","ns","names","keys","add","fields","values","methods","getEnum","Error","object","extend","TypeError","prev","remove","setOptions","_edition","_defaultEdition","onAdd","onRemove","define","path","isString","split","Array","isArray","ptr","part","shift","resolveAll","_resolveFeaturesRecursive","resolve","edition","forEach","lookup","filterTypes","parentAlreadyChecked","root","flatPath","join","slice","found","_fullyQualifiedObjects","indexOf","_lookupImpl","current","hasOwnProperty","exact","lookupType","lookupEnum","lookupTypeOrEnum","lookupService","_configure","Type_","Service_","Enum_"],"sources":["/home/linux-1/projects/web-server-app/imx8mp-web-client/node_modules/protobufjs/src/namespace.js"],"sourcesContent":["\"use strict\";\nmodule.exports = Namespace;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\nvar Field    = require(\"./field\"),\n    util     = require(\"./util\"),\n    OneOf    = require(\"./oneof\");\n\nvar Type,    // cyclic\n    Service,\n    Enum;\n\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */\nNamespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */\nfunction arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length))\n        return undefined;\n    var obj = {};\n    for (var i = 0; i < array.length; ++i)\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\n\nNamespace.arrayToJSON = arrayToJSON;\n\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id)\n                return true;\n    return false;\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (reserved[i] === name)\n                return true;\n    return false;\n};\n\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */\nfunction Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */\n    this.nested = undefined; // toJSON\n\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */\n    this._nestedArray = null;\n\n    /**\n     * Cache lookup calls for any objects contains anywhere under this namespace.\n     * This drastically speeds up resolve for large cross-linked protos where the same\n     * types are looked up repeatedly.\n     * @type {Object.<string,ReflectionObject|null>}\n     * @private\n     */\n    this._lookupCache = {};\n\n    /**\n     * Whether or not objects contained in this namespace need feature resolution.\n     * @type {boolean}\n     * @protected\n     */\n    this._needsRecursiveFeatureResolution = true;\n\n    /**\n     * Whether or not objects contained in this namespace need a resolve.\n     * @type {boolean}\n     * @protected\n     */\n    this._needsRecursiveResolve = true;\n}\n\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    namespace._lookupCache = {};\n\n    // Also clear parent caches, since they include nested lookups.\n    var parent = namespace;\n    while(parent = parent.parent) {\n        parent._lookupCache = {};\n    }\n    return namespace;\n}\n\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */\n\n/**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */\n\n/**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\n */\n\n/**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\" , this.options,\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */\n    if (nestedJson) {\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n            nested = nestedJson[names[i]];\n            ns.add( // most to least likely\n                ( nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : nested.id !== undefined\n                ? Field.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    }\n    return this;\n};\n\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */\nNamespace.prototype.get = function get(name) {\n    return this.nested && this.nested[name]\n        || null;\n};\n\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */\nNamespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum)\n        return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */\nNamespace.prototype.add = function add(object) {\n\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))\n        throw TypeError(\"object must be a valid nested object\");\n\n    if (!this.nested)\n        this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for (var i = 0; i < nested.length; ++i)\n                    object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested)\n                    this.nested = {};\n                object.setOptions(prev.options, true);\n\n            } else\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n\n    if (!(this instanceof Type || this instanceof Service || this instanceof Enum || this instanceof Field)) {\n        // This is a package or a root namespace.\n        if (!object._edition) {\n            // Make sure that some edition is set if it hasn't already been specified.\n            object._edition = object._defaultEdition;\n        }\n    }\n\n    this._needsRecursiveFeatureResolution = true;\n    this._needsRecursiveResolve = true;\n\n    // Also clear parent caches, since they need to recurse down.\n    var parent = this;\n    while(parent = parent.parent) {\n        parent._needsRecursiveFeatureResolution = true;\n        parent._needsRecursiveResolve = true;\n    }\n\n    object.onAdd(this);\n    return clearCache(this);\n};\n\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */\nNamespace.prototype.remove = function remove(object) {\n\n    if (!(object instanceof ReflectionObject))\n        throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this)\n        throw Error(object + \" is not a member of \" + this);\n\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length)\n        this.nested = undefined;\n\n    object.onRemove(this);\n    return clearCache(this);\n};\n\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */\nNamespace.prototype.define = function define(path, json) {\n\n    if (util.isString(path))\n        path = path.split(\".\");\n    else if (!Array.isArray(path))\n        throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\")\n        throw Error(\"path must be relative\");\n\n    var ptr = this;\n    while (path.length > 0) {\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace))\n                throw Error(\"path conflicts with non-namespace objects\");\n        } else\n            ptr.add(ptr = new Namespace(part));\n    }\n    if (json)\n        ptr.addJSON(json);\n    return ptr;\n};\n\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */\nNamespace.prototype.resolveAll = function resolveAll() {\n    if (!this._needsRecursiveResolve) return this;\n\n    this._resolveFeaturesRecursive(this._edition);\n\n    var nested = this.nestedArray, i = 0;\n    this.resolve();\n    while (i < nested.length)\n        if (nested[i] instanceof Namespace)\n            nested[i++].resolveAll();\n        else\n            nested[i++].resolve();\n    this._needsRecursiveResolve = false;\n    return this;\n};\n\n/**\n * @override\n */\nNamespace.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n    if (!this._needsRecursiveFeatureResolution) return this;\n    this._needsRecursiveFeatureResolution = false;\n\n    edition = this._edition || edition;\n\n    ReflectionObject.prototype._resolveFeaturesRecursive.call(this, edition);\n    this.nestedArray.forEach(nested => {\n        nested._resolveFeaturesRecursive(edition);\n    });\n    return this;\n};\n\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n    /* istanbul ignore next */\n    if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes))\n        filterTypes = [ filterTypes ];\n\n    if (util.isString(path) && path.length) {\n        if (path === \".\")\n            return this.root;\n        path = path.split(\".\");\n    } else if (!path.length)\n        return this;\n\n    var flatPath = path.join(\".\");\n\n    // Start at root if path is absolute\n    if (path[0] === \"\")\n        return this.root.lookup(path.slice(1), filterTypes);\n\n    // Early bailout for objects with matching absolute paths\n    var found = this.root._fullyQualifiedObjects && this.root._fullyQualifiedObjects[\".\" + flatPath];\n    if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n        return found;\n    }\n\n    // Do a regular lookup at this namespace and below\n    found = this._lookupImpl(path, flatPath);\n    if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n        return found;\n    }\n\n    if (parentAlreadyChecked)\n        return null;\n\n    // If there hasn't been a match, walk up the tree and look more broadly\n    var current = this;\n    while (current.parent) {\n        found = current.parent._lookupImpl(path, flatPath);\n        if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n            return found;\n        }\n        current = current.parent;\n    }\n    return null;\n};\n\n/**\n * Internal helper for lookup that handles searching just at this namespace and below along with caching.\n * @param {string[]} path Path to look up\n * @param {string} flatPath Flattened version of the path to use as a cache key\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @private\n */\nNamespace.prototype._lookupImpl = function lookup(path, flatPath) {\n    if(Object.prototype.hasOwnProperty.call(this._lookupCache, flatPath)) {\n        return this._lookupCache[flatPath];\n    }\n\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    var exact = null;\n    if (found) {\n        if (path.length === 1) {\n            exact = found;\n        } else if (found instanceof Namespace) {\n            path = path.slice(1);\n            exact = found._lookupImpl(path, path.join(\".\"));\n        }\n\n    // Otherwise try each nested namespace\n    } else {\n        for (var i = 0; i < this.nestedArray.length; ++i)\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i]._lookupImpl(path, flatPath)))\n                exact = found;\n    }\n\n    // Set this even when null, so that when we walk up the tree we can quickly bail on repeated checks back down.\n    this._lookupCache[flatPath] = exact;\n    return exact;\n};\n\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */\nNamespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [ Type ]);\n    if (!found)\n        throw Error(\"no such type: \" + path);\n    return found;\n};\n\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [ Enum ]);\n    if (!found)\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [ Type, Enum ]);\n    if (!found)\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */\nNamespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [ Service ]);\n    if (!found)\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type    = Type_;\n    Service = Service_;\n    Enum    = Enum_;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}