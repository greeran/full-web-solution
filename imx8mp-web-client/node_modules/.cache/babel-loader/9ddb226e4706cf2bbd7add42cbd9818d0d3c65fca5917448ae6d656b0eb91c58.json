{"ast":null,"code":"import mqtt from 'mqtt';\n// Remove protobufService import\nimport * as fileops from '../types/fileops_pb';\nclass MQTTService {\n  constructor() {\n    this.client = null;\n    this.config = null;\n    this.sensorData = {};\n    this.listeners = [];\n    this.fileUploadResultListener = null;\n  }\n  async connect(config) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        this.config = config;\n        const url = `ws://${config.host}:8083`;\n        this.client = mqtt.connect(url, {\n          clientId: config.client_id,\n          clean: true,\n          connectTimeout: 4000,\n          reconnectPeriod: 1000\n        });\n        this.client.on('connect', () => {\n          this.subscribeToTopics();\n          resolve();\n        });\n        this.client.on('message', (topic, message) => {\n          this.handleMessage(topic, message);\n        });\n        this.client.on('error', error => {\n          reject(error);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  subscribeToTopics() {\n    if (!this.client || !this.config) return;\n    Object.entries(this.config.topics).forEach(([key, topicConfig]) => {\n      this.client.subscribe(topicConfig.topic);\n    });\n  }\n  handleMessage(topic, message) {\n    // Handle sensor topics as before...\n    // Handle file upload result topic\n    if (topic === 'uploads/success' && this.fileUploadResultListener) {\n      try {\n        const result = fileops.decodeFileUploadResult(message);\n        this.fileUploadResultListener(result);\n      } catch (e) {\n        console.error('Failed to decode FileUploadResult:', e);\n      }\n    }\n  }\n\n  // --- File Upload via MQTT ---\n  async uploadFileViaMQTT(file, uploadDirectory, allowedExtensions, publishTopic, returnTopic) {\n    if (!this.client) throw new Error('MQTT client not connected');\n    const extension = file.name.substring(file.name.lastIndexOf('.'));\n    if (!allowedExtensions.includes(extension)) {\n      throw new Error('File extension not allowed');\n    }\n    const arrayBuffer = await file.arrayBuffer();\n    const payload = fileops.encodeFileUploadRequest({\n      filename: file.name,\n      extension,\n      file_data: new Uint8Array(arrayBuffer),\n      upload_directory: uploadDirectory\n    });\n    // Publish the file upload request\n    this.client.publish(publishTopic, payload);\n    // Optionally subscribe to return topic and wait for result\n    if (returnTopic) {\n      return new Promise((resolve, reject) => {\n        this.fileUploadResultListener = result => {\n          this.client.unsubscribe(returnTopic);\n          this.fileUploadResultListener = null;\n          resolve(result);\n        };\n        this.client.subscribe(returnTopic);\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n  onSensorDataUpdate(callback) {\n    this.listeners.push(callback);\n  }\n  getSensorData() {\n    return {\n      ...this.sensorData\n    };\n  }\n  disconnect() {\n    if (this.client) {\n      this.client.end();\n      this.client = null;\n    }\n  }\n  isConnected() {\n    var _this$client;\n    return ((_this$client = this.client) === null || _this$client === void 0 ? void 0 : _this$client.connected) || false;\n  }\n\n  // Protobuf helpers (no longer needed for file upload)\n}\nexport const mqttService = new MQTTService();","map":{"version":3,"names":["mqtt","fileops","MQTTService","constructor","client","config","sensorData","listeners","fileUploadResultListener","connect","Promise","resolve","reject","url","host","clientId","client_id","clean","connectTimeout","reconnectPeriod","on","subscribeToTopics","topic","message","handleMessage","error","Object","entries","topics","forEach","key","topicConfig","subscribe","result","decodeFileUploadResult","e","console","uploadFileViaMQTT","file","uploadDirectory","allowedExtensions","publishTopic","returnTopic","Error","extension","name","substring","lastIndexOf","includes","arrayBuffer","payload","encodeFileUploadRequest","filename","file_data","Uint8Array","upload_directory","publish","unsubscribe","onSensorDataUpdate","callback","push","getSensorData","disconnect","end","isConnected","_this$client","connected","mqttService"],"sources":["/home/linux-1/projects/web-server-app/imx8mp-web-client/src/services/mqttService.ts"],"sourcesContent":["import mqtt, { MqttClient } from 'mqtt';\nimport { SensorData, MQTTConfig } from '../types';\n// Remove protobufService import\nimport * as fileops from '../types/fileops_pb';\n\nclass MQTTService {\n  private client: MqttClient | null = null;\n  private config: MQTTConfig | null = null;\n  private sensorData: { [key: string]: SensorData } = {};\n  private listeners: ((data: { [key: string]: SensorData }) => void)[] = [];\n  private fileUploadResultListener: ((result: any) => void) | null = null;\n\n  async connect(config: MQTTConfig): Promise<void> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        this.config = config;\n        const url = `ws://${config.host}:8083`;\n        this.client = mqtt.connect(url, {\n          clientId: config.client_id,\n          clean: true,\n          connectTimeout: 4000,\n          reconnectPeriod: 1000,\n        });\n        this.client.on('connect', () => {\n          this.subscribeToTopics();\n          resolve();\n        });\n        this.client.on('message', (topic, message) => {\n          this.handleMessage(topic, message);\n        });\n        this.client.on('error', (error) => {\n          reject(error);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  private subscribeToTopics(): void {\n    if (!this.client || !this.config) return;\n    Object.entries(this.config.topics).forEach(([key, topicConfig]) => {\n      this.client!.subscribe(topicConfig.topic);\n    });\n  }\n\n  private handleMessage(topic: string, message: Buffer): void {\n    // Handle sensor topics as before...\n    // Handle file upload result topic\n    if (topic === 'uploads/success' && this.fileUploadResultListener) {\n      try {\n        const result = fileops.decodeFileUploadResult(message);\n        this.fileUploadResultListener(result);\n      } catch (e) {\n        console.error('Failed to decode FileUploadResult:', e);\n      }\n    }\n  }\n\n  // --- File Upload via MQTT ---\n  async uploadFileViaMQTT(file: File, uploadDirectory: string, allowedExtensions: string[], publishTopic: string, returnTopic?: string): Promise<any> {\n    if (!this.client) throw new Error('MQTT client not connected');\n    const extension = file.name.substring(file.name.lastIndexOf('.'));\n    if (!allowedExtensions.includes(extension)) {\n      throw new Error('File extension not allowed');\n    }\n    const arrayBuffer = await file.arrayBuffer();\n    const payload = fileops.encodeFileUploadRequest({\n      filename: file.name,\n      extension,\n      file_data: new Uint8Array(arrayBuffer),\n      upload_directory: uploadDirectory,\n    });\n    // Publish the file upload request\n    this.client.publish(publishTopic, payload);\n    // Optionally subscribe to return topic and wait for result\n    if (returnTopic) {\n      return new Promise((resolve, reject) => {\n        this.fileUploadResultListener = (result) => {\n          this.client!.unsubscribe(returnTopic);\n          this.fileUploadResultListener = null;\n          resolve(result);\n        };\n        this.client!.subscribe(returnTopic);\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  onSensorDataUpdate(callback: (data: { [key: string]: SensorData }) => void): void {\n    this.listeners.push(callback);\n  }\n\n  getSensorData(): { [key: string]: SensorData } {\n    return { ...this.sensorData };\n  }\n\n  disconnect(): void {\n    if (this.client) {\n      this.client.end();\n      this.client = null;\n    }\n  }\n\n  isConnected(): boolean {\n    return this.client?.connected || false;\n  }\n\n  // Protobuf helpers (no longer needed for file upload)\n}\n\nexport const mqttService = new MQTTService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}