{"ast":null,"code":"export function encodeFileUploadRequest(message) {\n  let bb = popByteBuffer();\n  _encodeFileUploadRequest(message, bb);\n  return toUint8Array(bb);\n}\nfunction _encodeFileUploadRequest(message, bb) {\n  // optional string filename = 1;\n  let $filename = message.filename;\n  if ($filename !== undefined) {\n    writeVarint32(bb, 10);\n    writeString(bb, $filename);\n  }\n\n  // optional string extension = 2;\n  let $extension = message.extension;\n  if ($extension !== undefined) {\n    writeVarint32(bb, 18);\n    writeString(bb, $extension);\n  }\n\n  // optional bytes file_data = 3;\n  let $file_data = message.file_data;\n  if ($file_data !== undefined) {\n    writeVarint32(bb, 26);\n    writeVarint32(bb, $file_data.length), writeBytes(bb, $file_data);\n  }\n\n  // optional string upload_directory = 4;\n  let $upload_directory = message.upload_directory;\n  if ($upload_directory !== undefined) {\n    writeVarint32(bb, 34);\n    writeString(bb, $upload_directory);\n  }\n}\nexport function decodeFileUploadRequest(binary) {\n  return _decodeFileUploadRequest(wrapByteBuffer(binary));\n}\nfunction _decodeFileUploadRequest(bb) {\n  let message = {};\n  end_of_message: while (!isAtEnd(bb)) {\n    let tag = readVarint32(bb);\n    switch (tag >>> 3) {\n      case 0:\n        break end_of_message;\n\n      // optional string filename = 1;\n      case 1:\n        {\n          message.filename = readString(bb, readVarint32(bb));\n          break;\n        }\n\n      // optional string extension = 2;\n      case 2:\n        {\n          message.extension = readString(bb, readVarint32(bb));\n          break;\n        }\n\n      // optional bytes file_data = 3;\n      case 3:\n        {\n          message.file_data = readBytes(bb, readVarint32(bb));\n          break;\n        }\n\n      // optional string upload_directory = 4;\n      case 4:\n        {\n          message.upload_directory = readString(bb, readVarint32(bb));\n          break;\n        }\n      default:\n        skipUnknownField(bb, tag & 7);\n    }\n  }\n  return message;\n}\nexport function encodeFileUploadResult(message) {\n  let bb = popByteBuffer();\n  _encodeFileUploadResult(message, bb);\n  return toUint8Array(bb);\n}\nfunction _encodeFileUploadResult(message, bb) {\n  // optional string filename = 1;\n  let $filename = message.filename;\n  if ($filename !== undefined) {\n    writeVarint32(bb, 10);\n    writeString(bb, $filename);\n  }\n\n  // optional string full_path = 2;\n  let $full_path = message.full_path;\n  if ($full_path !== undefined) {\n    writeVarint32(bb, 18);\n    writeString(bb, $full_path);\n  }\n\n  // optional bool success = 3;\n  let $success = message.success;\n  if ($success !== undefined) {\n    writeVarint32(bb, 24);\n    writeByte(bb, $success ? 1 : 0);\n  }\n\n  // optional string error_message = 4;\n  let $error_message = message.error_message;\n  if ($error_message !== undefined) {\n    writeVarint32(bb, 34);\n    writeString(bb, $error_message);\n  }\n}\nexport function decodeFileUploadResult(binary) {\n  return _decodeFileUploadResult(wrapByteBuffer(binary));\n}\nfunction _decodeFileUploadResult(bb) {\n  let message = {};\n  end_of_message: while (!isAtEnd(bb)) {\n    let tag = readVarint32(bb);\n    switch (tag >>> 3) {\n      case 0:\n        break end_of_message;\n\n      // optional string filename = 1;\n      case 1:\n        {\n          message.filename = readString(bb, readVarint32(bb));\n          break;\n        }\n\n      // optional string full_path = 2;\n      case 2:\n        {\n          message.full_path = readString(bb, readVarint32(bb));\n          break;\n        }\n\n      // optional bool success = 3;\n      case 3:\n        {\n          message.success = !!readByte(bb);\n          break;\n        }\n\n      // optional string error_message = 4;\n      case 4:\n        {\n          message.error_message = readString(bb, readVarint32(bb));\n          break;\n        }\n      default:\n        skipUnknownField(bb, tag & 7);\n    }\n  }\n  return message;\n}\nfunction pushTemporaryLength(bb) {\n  let length = readVarint32(bb);\n  let limit = bb.limit;\n  bb.limit = bb.offset + length;\n  return limit;\n}\nfunction skipUnknownField(bb, type) {\n  switch (type) {\n    case 0:\n      while (readByte(bb) & 0x80) {}\n      break;\n    case 2:\n      skip(bb, readVarint32(bb));\n      break;\n    case 5:\n      skip(bb, 4);\n      break;\n    case 1:\n      skip(bb, 8);\n      break;\n    default:\n      throw new Error(\"Unimplemented type: \" + type);\n  }\n}\nfunction stringToLong(value) {\n  return {\n    low: value.charCodeAt(0) | value.charCodeAt(1) << 16,\n    high: value.charCodeAt(2) | value.charCodeAt(3) << 16,\n    unsigned: false\n  };\n}\nfunction longToString(value) {\n  let low = value.low;\n  let high = value.high;\n  return String.fromCharCode(low & 0xFFFF, low >>> 16, high & 0xFFFF, high >>> 16);\n}\n\n// The code below was modified from https://github.com/protobufjs/bytebuffer.js\n// which is under the Apache License 2.0.\n\nlet f32 = new Float32Array(1);\nlet f32_u8 = new Uint8Array(f32.buffer);\nlet f64 = new Float64Array(1);\nlet f64_u8 = new Uint8Array(f64.buffer);\nfunction intToLong(value) {\n  value |= 0;\n  return {\n    low: value,\n    high: value >> 31,\n    unsigned: value >= 0\n  };\n}\nlet bbStack = [];\nfunction popByteBuffer() {\n  const bb = bbStack.pop();\n  if (!bb) return {\n    bytes: new Uint8Array(64),\n    offset: 0,\n    limit: 0\n  };\n  bb.offset = bb.limit = 0;\n  return bb;\n}\nfunction pushByteBuffer(bb) {\n  bbStack.push(bb);\n}\nfunction wrapByteBuffer(bytes) {\n  return {\n    bytes,\n    offset: 0,\n    limit: bytes.length\n  };\n}\nfunction toUint8Array(bb) {\n  let bytes = bb.bytes;\n  let limit = bb.limit;\n  return bytes.length === limit ? bytes : bytes.subarray(0, limit);\n}\nfunction skip(bb, offset) {\n  if (bb.offset + offset > bb.limit) {\n    throw new Error('Skip past limit');\n  }\n  bb.offset += offset;\n}\nfunction isAtEnd(bb) {\n  return bb.offset >= bb.limit;\n}\nfunction grow(bb, count) {\n  let bytes = bb.bytes;\n  let offset = bb.offset;\n  let limit = bb.limit;\n  let finalOffset = offset + count;\n  if (finalOffset > bytes.length) {\n    let newBytes = new Uint8Array(finalOffset * 2);\n    newBytes.set(bytes);\n    bb.bytes = newBytes;\n  }\n  bb.offset = finalOffset;\n  if (finalOffset > limit) {\n    bb.limit = finalOffset;\n  }\n  return offset;\n}\nfunction advance(bb, count) {\n  let offset = bb.offset;\n  if (offset + count > bb.limit) {\n    throw new Error('Read past limit');\n  }\n  bb.offset += count;\n  return offset;\n}\nfunction readBytes(bb, count) {\n  let offset = advance(bb, count);\n  return bb.bytes.subarray(offset, offset + count);\n}\nfunction writeBytes(bb, buffer) {\n  let offset = grow(bb, buffer.length);\n  bb.bytes.set(buffer, offset);\n}\nfunction readString(bb, count) {\n  // Sadly a hand-coded UTF8 decoder is much faster than subarray+TextDecoder in V8\n  let offset = advance(bb, count);\n  let fromCharCode = String.fromCharCode;\n  let bytes = bb.bytes;\n  let invalid = '\\uFFFD';\n  let text = '';\n  for (let i = 0; i < count; i++) {\n    let c1 = bytes[i + offset],\n      c2,\n      c3,\n      c4,\n      c;\n\n    // 1 byte\n    if ((c1 & 0x80) === 0) {\n      text += fromCharCode(c1);\n    }\n\n    // 2 bytes\n    else if ((c1 & 0xE0) === 0xC0) {\n      if (i + 1 >= count) text += invalid;else {\n        c2 = bytes[i + offset + 1];\n        if ((c2 & 0xC0) !== 0x80) text += invalid;else {\n          c = (c1 & 0x1F) << 6 | c2 & 0x3F;\n          if (c < 0x80) text += invalid;else {\n            text += fromCharCode(c);\n            i++;\n          }\n        }\n      }\n    }\n\n    // 3 bytes\n    else if ((c1 & 0xF0) == 0xE0) {\n      if (i + 2 >= count) text += invalid;else {\n        c2 = bytes[i + offset + 1];\n        c3 = bytes[i + offset + 2];\n        if (((c2 | c3 << 8) & 0xC0C0) !== 0x8080) text += invalid;else {\n          c = (c1 & 0x0F) << 12 | (c2 & 0x3F) << 6 | c3 & 0x3F;\n          if (c < 0x0800 || c >= 0xD800 && c <= 0xDFFF) text += invalid;else {\n            text += fromCharCode(c);\n            i += 2;\n          }\n        }\n      }\n    }\n\n    // 4 bytes\n    else if ((c1 & 0xF8) == 0xF0) {\n      if (i + 3 >= count) text += invalid;else {\n        c2 = bytes[i + offset + 1];\n        c3 = bytes[i + offset + 2];\n        c4 = bytes[i + offset + 3];\n        if (((c2 | c3 << 8 | c4 << 16) & 0xC0C0C0) !== 0x808080) text += invalid;else {\n          c = (c1 & 0x07) << 0x12 | (c2 & 0x3F) << 0x0C | (c3 & 0x3F) << 0x06 | c4 & 0x3F;\n          if (c < 0x10000 || c > 0x10FFFF) text += invalid;else {\n            c -= 0x10000;\n            text += fromCharCode((c >> 10) + 0xD800, (c & 0x3FF) + 0xDC00);\n            i += 3;\n          }\n        }\n      }\n    } else text += invalid;\n  }\n  return text;\n}\nfunction writeString(bb, text) {\n  // Sadly a hand-coded UTF8 encoder is much faster than TextEncoder+set in V8\n  let n = text.length;\n  let byteCount = 0;\n\n  // Write the byte count first\n  for (let i = 0; i < n; i++) {\n    let c = text.charCodeAt(i);\n    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {\n      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;\n    }\n    byteCount += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n  writeVarint32(bb, byteCount);\n  let offset = grow(bb, byteCount);\n  let bytes = bb.bytes;\n\n  // Then write the bytes\n  for (let i = 0; i < n; i++) {\n    let c = text.charCodeAt(i);\n    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {\n      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;\n    }\n    if (c < 0x80) {\n      bytes[offset++] = c;\n    } else {\n      if (c < 0x800) {\n        bytes[offset++] = c >> 6 & 0x1F | 0xC0;\n      } else {\n        if (c < 0x10000) {\n          bytes[offset++] = c >> 12 & 0x0F | 0xE0;\n        } else {\n          bytes[offset++] = c >> 18 & 0x07 | 0xF0;\n          bytes[offset++] = c >> 12 & 0x3F | 0x80;\n        }\n        bytes[offset++] = c >> 6 & 0x3F | 0x80;\n      }\n      bytes[offset++] = c & 0x3F | 0x80;\n    }\n  }\n}\nfunction writeByteBuffer(bb, buffer) {\n  let offset = grow(bb, buffer.limit);\n  let from = bb.bytes;\n  let to = buffer.bytes;\n\n  // This for loop is much faster than subarray+set on V8\n  for (let i = 0, n = buffer.limit; i < n; i++) {\n    from[i + offset] = to[i];\n  }\n}\nfunction readByte(bb) {\n  return bb.bytes[advance(bb, 1)];\n}\nfunction writeByte(bb, value) {\n  let offset = grow(bb, 1);\n  bb.bytes[offset] = value;\n}\nfunction readFloat(bb) {\n  let offset = advance(bb, 4);\n  let bytes = bb.bytes;\n\n  // Manual copying is much faster than subarray+set in V8\n  f32_u8[0] = bytes[offset++];\n  f32_u8[1] = bytes[offset++];\n  f32_u8[2] = bytes[offset++];\n  f32_u8[3] = bytes[offset++];\n  return f32[0];\n}\nfunction writeFloat(bb, value) {\n  let offset = grow(bb, 4);\n  let bytes = bb.bytes;\n  f32[0] = value;\n\n  // Manual copying is much faster than subarray+set in V8\n  bytes[offset++] = f32_u8[0];\n  bytes[offset++] = f32_u8[1];\n  bytes[offset++] = f32_u8[2];\n  bytes[offset++] = f32_u8[3];\n}\nfunction readDouble(bb) {\n  let offset = advance(bb, 8);\n  let bytes = bb.bytes;\n\n  // Manual copying is much faster than subarray+set in V8\n  f64_u8[0] = bytes[offset++];\n  f64_u8[1] = bytes[offset++];\n  f64_u8[2] = bytes[offset++];\n  f64_u8[3] = bytes[offset++];\n  f64_u8[4] = bytes[offset++];\n  f64_u8[5] = bytes[offset++];\n  f64_u8[6] = bytes[offset++];\n  f64_u8[7] = bytes[offset++];\n  return f64[0];\n}\nfunction writeDouble(bb, value) {\n  let offset = grow(bb, 8);\n  let bytes = bb.bytes;\n  f64[0] = value;\n\n  // Manual copying is much faster than subarray+set in V8\n  bytes[offset++] = f64_u8[0];\n  bytes[offset++] = f64_u8[1];\n  bytes[offset++] = f64_u8[2];\n  bytes[offset++] = f64_u8[3];\n  bytes[offset++] = f64_u8[4];\n  bytes[offset++] = f64_u8[5];\n  bytes[offset++] = f64_u8[6];\n  bytes[offset++] = f64_u8[7];\n}\nfunction readInt32(bb) {\n  let offset = advance(bb, 4);\n  let bytes = bb.bytes;\n  return bytes[offset] | bytes[offset + 1] << 8 | bytes[offset + 2] << 16 | bytes[offset + 3] << 24;\n}\nfunction writeInt32(bb, value) {\n  let offset = grow(bb, 4);\n  let bytes = bb.bytes;\n  bytes[offset] = value;\n  bytes[offset + 1] = value >> 8;\n  bytes[offset + 2] = value >> 16;\n  bytes[offset + 3] = value >> 24;\n}\nfunction readInt64(bb, unsigned) {\n  return {\n    low: readInt32(bb),\n    high: readInt32(bb),\n    unsigned\n  };\n}\nfunction writeInt64(bb, value) {\n  writeInt32(bb, value.low);\n  writeInt32(bb, value.high);\n}\nfunction readVarint32(bb) {\n  let c = 0;\n  let value = 0;\n  let b;\n  do {\n    b = readByte(bb);\n    if (c < 32) value |= (b & 0x7F) << c;\n    c += 7;\n  } while (b & 0x80);\n  return value;\n}\nfunction writeVarint32(bb, value) {\n  value >>>= 0;\n  while (value >= 0x80) {\n    writeByte(bb, value & 0x7f | 0x80);\n    value >>>= 7;\n  }\n  writeByte(bb, value);\n}\nfunction readVarint64(bb, unsigned) {\n  let part0 = 0;\n  let part1 = 0;\n  let part2 = 0;\n  let b;\n  b = readByte(bb);\n  part0 = b & 0x7F;\n  if (b & 0x80) {\n    b = readByte(bb);\n    part0 |= (b & 0x7F) << 7;\n    if (b & 0x80) {\n      b = readByte(bb);\n      part0 |= (b & 0x7F) << 14;\n      if (b & 0x80) {\n        b = readByte(bb);\n        part0 |= (b & 0x7F) << 21;\n        if (b & 0x80) {\n          b = readByte(bb);\n          part1 = b & 0x7F;\n          if (b & 0x80) {\n            b = readByte(bb);\n            part1 |= (b & 0x7F) << 7;\n            if (b & 0x80) {\n              b = readByte(bb);\n              part1 |= (b & 0x7F) << 14;\n              if (b & 0x80) {\n                b = readByte(bb);\n                part1 |= (b & 0x7F) << 21;\n                if (b & 0x80) {\n                  b = readByte(bb);\n                  part2 = b & 0x7F;\n                  if (b & 0x80) {\n                    b = readByte(bb);\n                    part2 |= (b & 0x7F) << 7;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return {\n    low: part0 | part1 << 28,\n    high: part1 >>> 4 | part2 << 24,\n    unsigned\n  };\n}\nfunction writeVarint64(bb, value) {\n  let part0 = value.low >>> 0;\n  let part1 = (value.low >>> 28 | value.high << 4) >>> 0;\n  let part2 = value.high >>> 24;\n\n  // ref: src/google/protobuf/io/coded_stream.cc\n  let size = part2 === 0 ? part1 === 0 ? part0 < 1 << 14 ? part0 < 1 << 7 ? 1 : 2 : part0 < 1 << 21 ? 3 : 4 : part1 < 1 << 14 ? part1 < 1 << 7 ? 5 : 6 : part1 < 1 << 21 ? 7 : 8 : part2 < 1 << 7 ? 9 : 10;\n  let offset = grow(bb, size);\n  let bytes = bb.bytes;\n  switch (size) {\n    case 10:\n      bytes[offset + 9] = part2 >>> 7 & 0x01;\n    case 9:\n      bytes[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;\n    case 8:\n      bytes[offset + 7] = size !== 8 ? part1 >>> 21 | 0x80 : part1 >>> 21 & 0x7F;\n    case 7:\n      bytes[offset + 6] = size !== 7 ? part1 >>> 14 | 0x80 : part1 >>> 14 & 0x7F;\n    case 6:\n      bytes[offset + 5] = size !== 6 ? part1 >>> 7 | 0x80 : part1 >>> 7 & 0x7F;\n    case 5:\n      bytes[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;\n    case 4:\n      bytes[offset + 3] = size !== 4 ? part0 >>> 21 | 0x80 : part0 >>> 21 & 0x7F;\n    case 3:\n      bytes[offset + 2] = size !== 3 ? part0 >>> 14 | 0x80 : part0 >>> 14 & 0x7F;\n    case 2:\n      bytes[offset + 1] = size !== 2 ? part0 >>> 7 | 0x80 : part0 >>> 7 & 0x7F;\n    case 1:\n      bytes[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;\n  }\n}\nfunction readVarint32ZigZag(bb) {\n  let value = readVarint32(bb);\n\n  // ref: src/google/protobuf/wire_format_lite.h\n  return value >>> 1 ^ -(value & 1);\n}\nfunction writeVarint32ZigZag(bb, value) {\n  // ref: src/google/protobuf/wire_format_lite.h\n  writeVarint32(bb, value << 1 ^ value >> 31);\n}\nfunction readVarint64ZigZag(bb) {\n  let value = readVarint64(bb, /* unsigned */false);\n  let low = value.low;\n  let high = value.high;\n  let flip = -(low & 1);\n\n  // ref: src/google/protobuf/wire_format_lite.h\n  return {\n    low: (low >>> 1 | high << 31) ^ flip,\n    high: high >>> 1 ^ flip,\n    unsigned: false\n  };\n}\nfunction writeVarint64ZigZag(bb, value) {\n  let low = value.low;\n  let high = value.high;\n  let flip = high >> 31;\n\n  // ref: src/google/protobuf/wire_format_lite.h\n  writeVarint64(bb, {\n    low: low << 1 ^ flip,\n    high: (high << 1 | low >>> 31) ^ flip,\n    unsigned: false\n  });\n}","map":{"version":3,"names":["encodeFileUploadRequest","message","bb","popByteBuffer","_encodeFileUploadRequest","toUint8Array","$filename","filename","undefined","writeVarint32","writeString","$extension","extension","$file_data","file_data","length","writeBytes","$upload_directory","upload_directory","decodeFileUploadRequest","binary","_decodeFileUploadRequest","wrapByteBuffer","end_of_message","isAtEnd","tag","readVarint32","readString","readBytes","skipUnknownField","encodeFileUploadResult","_encodeFileUploadResult","$full_path","full_path","$success","success","writeByte","$error_message","error_message","decodeFileUploadResult","_decodeFileUploadResult","readByte","pushTemporaryLength","limit","offset","type","skip","Error","stringToLong","value","low","charCodeAt","high","unsigned","longToString","String","fromCharCode","f32","Float32Array","f32_u8","Uint8Array","buffer","f64","Float64Array","f64_u8","intToLong","bbStack","pop","bytes","pushByteBuffer","push","subarray","grow","count","finalOffset","newBytes","set","advance","invalid","text","i","c1","c2","c3","c4","c","n","byteCount","writeByteBuffer","from","to","readFloat","writeFloat","readDouble","writeDouble","readInt32","writeInt32","readInt64","writeInt64","b","readVarint64","part0","part1","part2","writeVarint64","size","readVarint32ZigZag","writeVarint32ZigZag","readVarint64ZigZag","flip","writeVarint64ZigZag"],"sources":["/home/linux-1/projects/web-server-app/imx8mp-web-client/src/types/fileops_pb.js"],"sourcesContent":["export function encodeFileUploadRequest(message) {\n  let bb = popByteBuffer();\n  _encodeFileUploadRequest(message, bb);\n  return toUint8Array(bb);\n}\n\nfunction _encodeFileUploadRequest(message, bb) {\n  // optional string filename = 1;\n  let $filename = message.filename;\n  if ($filename !== undefined) {\n    writeVarint32(bb, 10);\n    writeString(bb, $filename);\n  }\n\n  // optional string extension = 2;\n  let $extension = message.extension;\n  if ($extension !== undefined) {\n    writeVarint32(bb, 18);\n    writeString(bb, $extension);\n  }\n\n  // optional bytes file_data = 3;\n  let $file_data = message.file_data;\n  if ($file_data !== undefined) {\n    writeVarint32(bb, 26);\n    writeVarint32(bb, $file_data.length), writeBytes(bb, $file_data);\n  }\n\n  // optional string upload_directory = 4;\n  let $upload_directory = message.upload_directory;\n  if ($upload_directory !== undefined) {\n    writeVarint32(bb, 34);\n    writeString(bb, $upload_directory);\n  }\n}\n\nexport function decodeFileUploadRequest(binary) {\n  return _decodeFileUploadRequest(wrapByteBuffer(binary));\n}\n\nfunction _decodeFileUploadRequest(bb) {\n  let message = {};\n\n  end_of_message: while (!isAtEnd(bb)) {\n    let tag = readVarint32(bb);\n\n    switch (tag >>> 3) {\n      case 0:\n        break end_of_message;\n\n      // optional string filename = 1;\n      case 1: {\n        message.filename = readString(bb, readVarint32(bb));\n        break;\n      }\n\n      // optional string extension = 2;\n      case 2: {\n        message.extension = readString(bb, readVarint32(bb));\n        break;\n      }\n\n      // optional bytes file_data = 3;\n      case 3: {\n        message.file_data = readBytes(bb, readVarint32(bb));\n        break;\n      }\n\n      // optional string upload_directory = 4;\n      case 4: {\n        message.upload_directory = readString(bb, readVarint32(bb));\n        break;\n      }\n\n      default:\n        skipUnknownField(bb, tag & 7);\n    }\n  }\n\n  return message;\n}\n\nexport function encodeFileUploadResult(message) {\n  let bb = popByteBuffer();\n  _encodeFileUploadResult(message, bb);\n  return toUint8Array(bb);\n}\n\nfunction _encodeFileUploadResult(message, bb) {\n  // optional string filename = 1;\n  let $filename = message.filename;\n  if ($filename !== undefined) {\n    writeVarint32(bb, 10);\n    writeString(bb, $filename);\n  }\n\n  // optional string full_path = 2;\n  let $full_path = message.full_path;\n  if ($full_path !== undefined) {\n    writeVarint32(bb, 18);\n    writeString(bb, $full_path);\n  }\n\n  // optional bool success = 3;\n  let $success = message.success;\n  if ($success !== undefined) {\n    writeVarint32(bb, 24);\n    writeByte(bb, $success ? 1 : 0);\n  }\n\n  // optional string error_message = 4;\n  let $error_message = message.error_message;\n  if ($error_message !== undefined) {\n    writeVarint32(bb, 34);\n    writeString(bb, $error_message);\n  }\n}\n\nexport function decodeFileUploadResult(binary) {\n  return _decodeFileUploadResult(wrapByteBuffer(binary));\n}\n\nfunction _decodeFileUploadResult(bb) {\n  let message = {};\n\n  end_of_message: while (!isAtEnd(bb)) {\n    let tag = readVarint32(bb);\n\n    switch (tag >>> 3) {\n      case 0:\n        break end_of_message;\n\n      // optional string filename = 1;\n      case 1: {\n        message.filename = readString(bb, readVarint32(bb));\n        break;\n      }\n\n      // optional string full_path = 2;\n      case 2: {\n        message.full_path = readString(bb, readVarint32(bb));\n        break;\n      }\n\n      // optional bool success = 3;\n      case 3: {\n        message.success = !!readByte(bb);\n        break;\n      }\n\n      // optional string error_message = 4;\n      case 4: {\n        message.error_message = readString(bb, readVarint32(bb));\n        break;\n      }\n\n      default:\n        skipUnknownField(bb, tag & 7);\n    }\n  }\n\n  return message;\n}\n\nfunction pushTemporaryLength(bb) {\n  let length = readVarint32(bb);\n  let limit = bb.limit;\n  bb.limit = bb.offset + length;\n  return limit;\n}\n\nfunction skipUnknownField(bb, type) {\n  switch (type) {\n    case 0: while (readByte(bb) & 0x80) { } break;\n    case 2: skip(bb, readVarint32(bb)); break;\n    case 5: skip(bb, 4); break;\n    case 1: skip(bb, 8); break;\n    default: throw new Error(\"Unimplemented type: \" + type);\n  }\n}\n\nfunction stringToLong(value) {\n  return {\n    low: value.charCodeAt(0) | (value.charCodeAt(1) << 16),\n    high: value.charCodeAt(2) | (value.charCodeAt(3) << 16),\n    unsigned: false,\n  };\n}\n\nfunction longToString(value) {\n  let low = value.low;\n  let high = value.high;\n  return String.fromCharCode(\n    low & 0xFFFF,\n    low >>> 16,\n    high & 0xFFFF,\n    high >>> 16);\n}\n\n// The code below was modified from https://github.com/protobufjs/bytebuffer.js\n// which is under the Apache License 2.0.\n\nlet f32 = new Float32Array(1);\nlet f32_u8 = new Uint8Array(f32.buffer);\n\nlet f64 = new Float64Array(1);\nlet f64_u8 = new Uint8Array(f64.buffer);\n\nfunction intToLong(value) {\n  value |= 0;\n  return {\n    low: value,\n    high: value >> 31,\n    unsigned: value >= 0,\n  };\n}\n\nlet bbStack = [];\n\nfunction popByteBuffer() {\n  const bb = bbStack.pop();\n  if (!bb) return { bytes: new Uint8Array(64), offset: 0, limit: 0 };\n  bb.offset = bb.limit = 0;\n  return bb;\n}\n\nfunction pushByteBuffer(bb) {\n  bbStack.push(bb);\n}\n\nfunction wrapByteBuffer(bytes) {\n  return { bytes, offset: 0, limit: bytes.length };\n}\n\nfunction toUint8Array(bb) {\n  let bytes = bb.bytes;\n  let limit = bb.limit;\n  return bytes.length === limit ? bytes : bytes.subarray(0, limit);\n}\n\nfunction skip(bb, offset) {\n  if (bb.offset + offset > bb.limit) {\n    throw new Error('Skip past limit');\n  }\n  bb.offset += offset;\n}\n\nfunction isAtEnd(bb) {\n  return bb.offset >= bb.limit;\n}\n\nfunction grow(bb, count) {\n  let bytes = bb.bytes;\n  let offset = bb.offset;\n  let limit = bb.limit;\n  let finalOffset = offset + count;\n  if (finalOffset > bytes.length) {\n    let newBytes = new Uint8Array(finalOffset * 2);\n    newBytes.set(bytes);\n    bb.bytes = newBytes;\n  }\n  bb.offset = finalOffset;\n  if (finalOffset > limit) {\n    bb.limit = finalOffset;\n  }\n  return offset;\n}\n\nfunction advance(bb, count) {\n  let offset = bb.offset;\n  if (offset + count > bb.limit) {\n    throw new Error('Read past limit');\n  }\n  bb.offset += count;\n  return offset;\n}\n\nfunction readBytes(bb, count) {\n  let offset = advance(bb, count);\n  return bb.bytes.subarray(offset, offset + count);\n}\n\nfunction writeBytes(bb, buffer) {\n  let offset = grow(bb, buffer.length);\n  bb.bytes.set(buffer, offset);\n}\n\nfunction readString(bb, count) {\n  // Sadly a hand-coded UTF8 decoder is much faster than subarray+TextDecoder in V8\n  let offset = advance(bb, count);\n  let fromCharCode = String.fromCharCode;\n  let bytes = bb.bytes;\n  let invalid = '\\uFFFD';\n  let text = '';\n\n  for (let i = 0; i < count; i++) {\n    let c1 = bytes[i + offset], c2, c3, c4, c;\n\n    // 1 byte\n    if ((c1 & 0x80) === 0) {\n      text += fromCharCode(c1);\n    }\n\n    // 2 bytes\n    else if ((c1 & 0xE0) === 0xC0) {\n      if (i + 1 >= count) text += invalid;\n      else {\n        c2 = bytes[i + offset + 1];\n        if ((c2 & 0xC0) !== 0x80) text += invalid;\n        else {\n          c = ((c1 & 0x1F) << 6) | (c2 & 0x3F);\n          if (c < 0x80) text += invalid;\n          else {\n            text += fromCharCode(c);\n            i++;\n          }\n        }\n      }\n    }\n\n    // 3 bytes\n    else if ((c1 & 0xF0) == 0xE0) {\n      if (i + 2 >= count) text += invalid;\n      else {\n        c2 = bytes[i + offset + 1];\n        c3 = bytes[i + offset + 2];\n        if (((c2 | (c3 << 8)) & 0xC0C0) !== 0x8080) text += invalid;\n        else {\n          c = ((c1 & 0x0F) << 12) | ((c2 & 0x3F) << 6) | (c3 & 0x3F);\n          if (c < 0x0800 || (c >= 0xD800 && c <= 0xDFFF)) text += invalid;\n          else {\n            text += fromCharCode(c);\n            i += 2;\n          }\n        }\n      }\n    }\n\n    // 4 bytes\n    else if ((c1 & 0xF8) == 0xF0) {\n      if (i + 3 >= count) text += invalid;\n      else {\n        c2 = bytes[i + offset + 1];\n        c3 = bytes[i + offset + 2];\n        c4 = bytes[i + offset + 3];\n        if (((c2 | (c3 << 8) | (c4 << 16)) & 0xC0C0C0) !== 0x808080) text += invalid;\n        else {\n          c = ((c1 & 0x07) << 0x12) | ((c2 & 0x3F) << 0x0C) | ((c3 & 0x3F) << 0x06) | (c4 & 0x3F);\n          if (c < 0x10000 || c > 0x10FFFF) text += invalid;\n          else {\n            c -= 0x10000;\n            text += fromCharCode((c >> 10) + 0xD800, (c & 0x3FF) + 0xDC00);\n            i += 3;\n          }\n        }\n      }\n    }\n\n    else text += invalid;\n  }\n\n  return text;\n}\n\nfunction writeString(bb, text) {\n  // Sadly a hand-coded UTF8 encoder is much faster than TextEncoder+set in V8\n  let n = text.length;\n  let byteCount = 0;\n\n  // Write the byte count first\n  for (let i = 0; i < n; i++) {\n    let c = text.charCodeAt(i);\n    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {\n      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;\n    }\n    byteCount += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n  writeVarint32(bb, byteCount);\n\n  let offset = grow(bb, byteCount);\n  let bytes = bb.bytes;\n\n  // Then write the bytes\n  for (let i = 0; i < n; i++) {\n    let c = text.charCodeAt(i);\n    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {\n      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;\n    }\n    if (c < 0x80) {\n      bytes[offset++] = c;\n    } else {\n      if (c < 0x800) {\n        bytes[offset++] = ((c >> 6) & 0x1F) | 0xC0;\n      } else {\n        if (c < 0x10000) {\n          bytes[offset++] = ((c >> 12) & 0x0F) | 0xE0;\n        } else {\n          bytes[offset++] = ((c >> 18) & 0x07) | 0xF0;\n          bytes[offset++] = ((c >> 12) & 0x3F) | 0x80;\n        }\n        bytes[offset++] = ((c >> 6) & 0x3F) | 0x80;\n      }\n      bytes[offset++] = (c & 0x3F) | 0x80;\n    }\n  }\n}\n\nfunction writeByteBuffer(bb, buffer) {\n  let offset = grow(bb, buffer.limit);\n  let from = bb.bytes;\n  let to = buffer.bytes;\n\n  // This for loop is much faster than subarray+set on V8\n  for (let i = 0, n = buffer.limit; i < n; i++) {\n    from[i + offset] = to[i];\n  }\n}\n\nfunction readByte(bb) {\n  return bb.bytes[advance(bb, 1)];\n}\n\nfunction writeByte(bb, value) {\n  let offset = grow(bb, 1);\n  bb.bytes[offset] = value;\n}\n\nfunction readFloat(bb) {\n  let offset = advance(bb, 4);\n  let bytes = bb.bytes;\n\n  // Manual copying is much faster than subarray+set in V8\n  f32_u8[0] = bytes[offset++];\n  f32_u8[1] = bytes[offset++];\n  f32_u8[2] = bytes[offset++];\n  f32_u8[3] = bytes[offset++];\n  return f32[0];\n}\n\nfunction writeFloat(bb, value) {\n  let offset = grow(bb, 4);\n  let bytes = bb.bytes;\n  f32[0] = value;\n\n  // Manual copying is much faster than subarray+set in V8\n  bytes[offset++] = f32_u8[0];\n  bytes[offset++] = f32_u8[1];\n  bytes[offset++] = f32_u8[2];\n  bytes[offset++] = f32_u8[3];\n}\n\nfunction readDouble(bb) {\n  let offset = advance(bb, 8);\n  let bytes = bb.bytes;\n\n  // Manual copying is much faster than subarray+set in V8\n  f64_u8[0] = bytes[offset++];\n  f64_u8[1] = bytes[offset++];\n  f64_u8[2] = bytes[offset++];\n  f64_u8[3] = bytes[offset++];\n  f64_u8[4] = bytes[offset++];\n  f64_u8[5] = bytes[offset++];\n  f64_u8[6] = bytes[offset++];\n  f64_u8[7] = bytes[offset++];\n  return f64[0];\n}\n\nfunction writeDouble(bb, value) {\n  let offset = grow(bb, 8);\n  let bytes = bb.bytes;\n  f64[0] = value;\n\n  // Manual copying is much faster than subarray+set in V8\n  bytes[offset++] = f64_u8[0];\n  bytes[offset++] = f64_u8[1];\n  bytes[offset++] = f64_u8[2];\n  bytes[offset++] = f64_u8[3];\n  bytes[offset++] = f64_u8[4];\n  bytes[offset++] = f64_u8[5];\n  bytes[offset++] = f64_u8[6];\n  bytes[offset++] = f64_u8[7];\n}\n\nfunction readInt32(bb) {\n  let offset = advance(bb, 4);\n  let bytes = bb.bytes;\n  return (\n    bytes[offset] |\n    (bytes[offset + 1] << 8) |\n    (bytes[offset + 2] << 16) |\n    (bytes[offset + 3] << 24)\n  );\n}\n\nfunction writeInt32(bb, value) {\n  let offset = grow(bb, 4);\n  let bytes = bb.bytes;\n  bytes[offset] = value;\n  bytes[offset + 1] = value >> 8;\n  bytes[offset + 2] = value >> 16;\n  bytes[offset + 3] = value >> 24;\n}\n\nfunction readInt64(bb, unsigned) {\n  return {\n    low: readInt32(bb),\n    high: readInt32(bb),\n    unsigned,\n  };\n}\n\nfunction writeInt64(bb, value) {\n  writeInt32(bb, value.low);\n  writeInt32(bb, value.high);\n}\n\nfunction readVarint32(bb) {\n  let c = 0;\n  let value = 0;\n  let b;\n  do {\n    b = readByte(bb);\n    if (c < 32) value |= (b & 0x7F) << c;\n    c += 7;\n  } while (b & 0x80);\n  return value;\n}\n\nfunction writeVarint32(bb, value) {\n  value >>>= 0;\n  while (value >= 0x80) {\n    writeByte(bb, (value & 0x7f) | 0x80);\n    value >>>= 7;\n  }\n  writeByte(bb, value);\n}\n\nfunction readVarint64(bb, unsigned) {\n  let part0 = 0;\n  let part1 = 0;\n  let part2 = 0;\n  let b;\n\n  b = readByte(bb); part0 = (b & 0x7F); if (b & 0x80) {\n    b = readByte(bb); part0 |= (b & 0x7F) << 7; if (b & 0x80) {\n      b = readByte(bb); part0 |= (b & 0x7F) << 14; if (b & 0x80) {\n        b = readByte(bb); part0 |= (b & 0x7F) << 21; if (b & 0x80) {\n\n          b = readByte(bb); part1 = (b & 0x7F); if (b & 0x80) {\n            b = readByte(bb); part1 |= (b & 0x7F) << 7; if (b & 0x80) {\n              b = readByte(bb); part1 |= (b & 0x7F) << 14; if (b & 0x80) {\n                b = readByte(bb); part1 |= (b & 0x7F) << 21; if (b & 0x80) {\n\n                  b = readByte(bb); part2 = (b & 0x7F); if (b & 0x80) {\n                    b = readByte(bb); part2 |= (b & 0x7F) << 7;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    low: part0 | (part1 << 28),\n    high: (part1 >>> 4) | (part2 << 24),\n    unsigned,\n  };\n}\n\nfunction writeVarint64(bb, value) {\n  let part0 = value.low >>> 0;\n  let part1 = ((value.low >>> 28) | (value.high << 4)) >>> 0;\n  let part2 = value.high >>> 24;\n\n  // ref: src/google/protobuf/io/coded_stream.cc\n  let size =\n    part2 === 0 ?\n      part1 === 0 ?\n        part0 < 1 << 14 ?\n          part0 < 1 << 7 ? 1 : 2 :\n          part0 < 1 << 21 ? 3 : 4 :\n        part1 < 1 << 14 ?\n          part1 < 1 << 7 ? 5 : 6 :\n          part1 < 1 << 21 ? 7 : 8 :\n      part2 < 1 << 7 ? 9 : 10;\n\n  let offset = grow(bb, size);\n  let bytes = bb.bytes;\n\n  switch (size) {\n    case 10: bytes[offset + 9] = (part2 >>> 7) & 0x01;\n    case 9: bytes[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;\n    case 8: bytes[offset + 7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;\n    case 7: bytes[offset + 6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;\n    case 6: bytes[offset + 5] = size !== 6 ? (part1 >>> 7) | 0x80 : (part1 >>> 7) & 0x7F;\n    case 5: bytes[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;\n    case 4: bytes[offset + 3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;\n    case 3: bytes[offset + 2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;\n    case 2: bytes[offset + 1] = size !== 2 ? (part0 >>> 7) | 0x80 : (part0 >>> 7) & 0x7F;\n    case 1: bytes[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;\n  }\n}\n\nfunction readVarint32ZigZag(bb) {\n  let value = readVarint32(bb);\n\n  // ref: src/google/protobuf/wire_format_lite.h\n  return (value >>> 1) ^ -(value & 1);\n}\n\nfunction writeVarint32ZigZag(bb, value) {\n  // ref: src/google/protobuf/wire_format_lite.h\n  writeVarint32(bb, (value << 1) ^ (value >> 31));\n}\n\nfunction readVarint64ZigZag(bb) {\n  let value = readVarint64(bb, /* unsigned */ false);\n  let low = value.low;\n  let high = value.high;\n  let flip = -(low & 1);\n\n  // ref: src/google/protobuf/wire_format_lite.h\n  return {\n    low: ((low >>> 1) | (high << 31)) ^ flip,\n    high: (high >>> 1) ^ flip,\n    unsigned: false,\n  };\n}\n\nfunction writeVarint64ZigZag(bb, value) {\n  let low = value.low;\n  let high = value.high;\n  let flip = high >> 31;\n\n  // ref: src/google/protobuf/wire_format_lite.h\n  writeVarint64(bb, {\n    low: (low << 1) ^ flip,\n    high: ((high << 1) | (low >>> 31)) ^ flip,\n    unsigned: false,\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}