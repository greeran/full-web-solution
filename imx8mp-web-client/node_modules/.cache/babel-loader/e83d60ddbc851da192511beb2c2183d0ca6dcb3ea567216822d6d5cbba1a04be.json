{"ast":null,"code":"\"use strict\";\n\nmodule.exports = parse;\nparse.filename = null;\nparse.defaults = {\n  keepCase: false\n};\nvar tokenize = require(\"./tokenize\"),\n  Root = require(\"./root\"),\n  Type = require(\"./type\"),\n  Field = require(\"./field\"),\n  MapField = require(\"./mapfield\"),\n  OneOf = require(\"./oneof\"),\n  Enum = require(\"./enum\"),\n  Service = require(\"./service\"),\n  Method = require(\"./method\"),\n  ReflectionObject = require(\"./object\"),\n  types = require(\"./types\"),\n  util = require(\"./util\");\nvar base10Re = /^[1-9][0-9]*$/,\n  base10NegRe = /^-?[1-9][0-9]*$/,\n  base16Re = /^0[x][0-9a-fA-F]+$/,\n  base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\n  base8Re = /^0[0-7]+$/,\n  base8NegRe = /^-?0[0-7]+$/,\n  numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\n  nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n  typeRefRe = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;\n\n/**\n * Result object returned from {@link parse}.\n * @interface IParserResult\n * @property {string|undefined} package Package name, if declared\n * @property {string[]|undefined} imports Imports, if any\n * @property {string[]|undefined} weakImports Weak imports, if any\n * @property {Root} root Populated root instance\n */\n\n/**\n * Options modifying the behavior of {@link parse}.\n * @interface IParseOptions\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\n */\n\n/**\n * Options modifying the behavior of JSON serialization.\n * @interface IToJSONOptions\n * @property {boolean} [keepComments=false] Serializes comments.\n */\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @param {string} source Source contents\n * @param {Root} root Root to populate\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n */\nfunction parse(source, root, options) {\n  /* eslint-disable callback-return */\n  if (!(root instanceof Root)) {\n    options = root;\n    root = new Root();\n  }\n  if (!options) options = parse.defaults;\n  var preferTrailingComment = options.preferTrailingComment || false;\n  var tn = tokenize(source, options.alternateCommentMode || false),\n    next = tn.next,\n    push = tn.push,\n    peek = tn.peek,\n    skip = tn.skip,\n    cmnt = tn.cmnt;\n  var head = true,\n    pkg,\n    imports,\n    weakImports,\n    edition = \"proto2\";\n  var ptr = root;\n  var topLevelObjects = [];\n  var topLevelOptions = {};\n  var applyCase = options.keepCase ? function (name) {\n    return name;\n  } : util.camelCase;\n  function resolveFileFeatures() {\n    topLevelObjects.forEach(obj => {\n      obj._edition = edition;\n      Object.keys(topLevelOptions).forEach(opt => {\n        if (obj.getOption(opt) !== undefined) return;\n        obj.setOption(opt, topLevelOptions[opt], true);\n      });\n    });\n  }\n\n  /* istanbul ignore next */\n  function illegal(token, name, insideTryCatch) {\n    var filename = parse.filename;\n    if (!insideTryCatch) parse.filename = null;\n    return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n  }\n  function readString() {\n    var values = [],\n      token;\n    do {\n      /* istanbul ignore if */\n      if ((token = next()) !== \"\\\"\" && token !== \"'\") throw illegal(token);\n      values.push(next());\n      skip(token);\n      token = peek();\n    } while (token === \"\\\"\" || token === \"'\");\n    return values.join(\"\");\n  }\n  function readValue(acceptTypeRef) {\n    var token = next();\n    switch (token) {\n      case \"'\":\n      case \"\\\"\":\n        push(token);\n        return readString();\n      case \"true\":\n      case \"TRUE\":\n        return true;\n      case \"false\":\n      case \"FALSE\":\n        return false;\n    }\n    try {\n      return parseNumber(token, /* insideTryCatch */true);\n    } catch (e) {\n      /* istanbul ignore else */\n      if (acceptTypeRef && typeRefRe.test(token)) return token;\n\n      /* istanbul ignore next */\n      throw illegal(token, \"value\");\n    }\n  }\n  function readRanges(target, acceptStrings) {\n    var token, start;\n    do {\n      if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\")) {\n        var str = readString();\n        target.push(str);\n        if (edition >= 2023) {\n          throw illegal(str, \"id\");\n        }\n      } else {\n        try {\n          target.push([start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start]);\n        } catch (err) {\n          if (acceptStrings && typeRefRe.test(token) && edition >= 2023) {\n            target.push(token);\n          } else {\n            throw err;\n          }\n        }\n      }\n    } while (skip(\",\", true));\n    var dummy = {\n      options: undefined\n    };\n    dummy.setOption = function (name, value) {\n      if (this.options === undefined) this.options = {};\n      this.options[name] = value;\n    };\n    ifBlock(dummy, function parseRange_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(dummy, token); // skip\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseRange_line() {\n      parseInlineOptions(dummy); // skip\n    });\n  }\n  function parseNumber(token, insideTryCatch) {\n    var sign = 1;\n    if (token.charAt(0) === \"-\") {\n      sign = -1;\n      token = token.substring(1);\n    }\n    switch (token) {\n      case \"inf\":\n      case \"INF\":\n      case \"Inf\":\n        return sign * Infinity;\n      case \"nan\":\n      case \"NAN\":\n      case \"Nan\":\n      case \"NaN\":\n        return NaN;\n      case \"0\":\n        return 0;\n    }\n    if (base10Re.test(token)) return sign * parseInt(token, 10);\n    if (base16Re.test(token)) return sign * parseInt(token, 16);\n    if (base8Re.test(token)) return sign * parseInt(token, 8);\n\n    /* istanbul ignore else */\n    if (numberRe.test(token)) return sign * parseFloat(token);\n\n    /* istanbul ignore next */\n    throw illegal(token, \"number\", insideTryCatch);\n  }\n  function parseId(token, acceptNegative) {\n    switch (token) {\n      case \"max\":\n      case \"MAX\":\n      case \"Max\":\n        return 536870911;\n      case \"0\":\n        return 0;\n    }\n\n    /* istanbul ignore if */\n    if (!acceptNegative && token.charAt(0) === \"-\") throw illegal(token, \"id\");\n    if (base10NegRe.test(token)) return parseInt(token, 10);\n    if (base16NegRe.test(token)) return parseInt(token, 16);\n\n    /* istanbul ignore else */\n    if (base8NegRe.test(token)) return parseInt(token, 8);\n\n    /* istanbul ignore next */\n    throw illegal(token, \"id\");\n  }\n  function parsePackage() {\n    /* istanbul ignore if */\n    if (pkg !== undefined) throw illegal(\"package\");\n    pkg = next();\n\n    /* istanbul ignore if */\n    if (!typeRefRe.test(pkg)) throw illegal(pkg, \"name\");\n    ptr = ptr.define(pkg);\n    skip(\";\");\n  }\n  function parseImport() {\n    var token = peek();\n    var whichImports;\n    switch (token) {\n      case \"weak\":\n        whichImports = weakImports || (weakImports = []);\n        next();\n        break;\n      case \"public\":\n        next();\n      // eslint-disable-next-line no-fallthrough\n      default:\n        whichImports = imports || (imports = []);\n        break;\n    }\n    token = readString();\n    skip(\";\");\n    whichImports.push(token);\n  }\n  function parseSyntax() {\n    skip(\"=\");\n    edition = readString();\n\n    /* istanbul ignore if */\n    if (edition < 2023) throw illegal(edition, \"syntax\");\n    skip(\";\");\n  }\n  function parseEdition() {\n    skip(\"=\");\n    edition = readString();\n    const supportedEditions = [\"2023\"];\n\n    /* istanbul ignore if */\n    if (!supportedEditions.includes(edition)) throw illegal(edition, \"edition\");\n    skip(\";\");\n  }\n  function parseCommon(parent, token) {\n    switch (token) {\n      case \"option\":\n        parseOption(parent, token);\n        skip(\";\");\n        return true;\n      case \"message\":\n        parseType(parent, token);\n        return true;\n      case \"enum\":\n        parseEnum(parent, token);\n        return true;\n      case \"service\":\n        parseService(parent, token);\n        return true;\n      case \"extend\":\n        parseExtension(parent, token);\n        return true;\n    }\n    return false;\n  }\n  function ifBlock(obj, fnIf, fnElse) {\n    var trailingLine = tn.line;\n    if (obj) {\n      if (typeof obj.comment !== \"string\") {\n        obj.comment = cmnt(); // try block-type comment\n      }\n      obj.filename = parse.filename;\n    }\n    if (skip(\"{\", true)) {\n      var token;\n      while ((token = next()) !== \"}\") fnIf(token);\n      skip(\";\", true);\n    } else {\n      if (fnElse) fnElse();\n      skip(\";\");\n      if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment)) obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\n    }\n  }\n  function parseType(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"type name\");\n    var type = new Type(token);\n    ifBlock(type, function parseType_block(token) {\n      if (parseCommon(type, token)) return;\n      switch (token) {\n        case \"map\":\n          parseMapField(type, token);\n          break;\n        case \"required\":\n          if (edition !== \"proto2\") throw illegal(token);\n        /* eslint-disable no-fallthrough */\n        case \"repeated\":\n          parseField(type, token);\n          break;\n        case \"optional\":\n          /* istanbul ignore if */\n          if (edition === \"proto3\") {\n            parseField(type, \"proto3_optional\");\n          } else if (edition !== \"proto2\") {\n            throw illegal(token);\n          } else {\n            parseField(type, \"optional\");\n          }\n          break;\n        case \"oneof\":\n          parseOneOf(type, token);\n          break;\n        case \"extensions\":\n          readRanges(type.extensions || (type.extensions = []));\n          break;\n        case \"reserved\":\n          readRanges(type.reserved || (type.reserved = []), true);\n          break;\n        default:\n          /* istanbul ignore if */\n          if (edition === \"proto2\" || !typeRefRe.test(token)) {\n            throw illegal(token);\n          }\n          push(token);\n          parseField(type, \"optional\");\n          break;\n      }\n    });\n    parent.add(type);\n    if (parent === ptr) {\n      topLevelObjects.push(type);\n    }\n  }\n  function parseField(parent, rule, extend) {\n    var type = next();\n    if (type === \"group\") {\n      parseGroup(parent, rule);\n      return;\n    }\n    // Type names can consume multiple tokens, in multiple variants:\n    //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\n    //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n    //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n    //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\n    // Keep reading tokens until we get a type name with no period at the end,\n    // and the next token does not start with a period.\n    while (type.endsWith(\".\") || peek().startsWith(\".\")) {\n      type += next();\n    }\n\n    /* istanbul ignore if */\n    if (!typeRefRe.test(type)) throw illegal(type, \"type\");\n    var name = next();\n\n    /* istanbul ignore if */\n\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    name = applyCase(name);\n    skip(\"=\");\n    var field = new Field(name, parseId(next()), type, rule, extend);\n    ifBlock(field, function parseField_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(field, token);\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseField_line() {\n      parseInlineOptions(field);\n    });\n    if (rule === \"proto3_optional\") {\n      // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\n      var oneof = new OneOf(\"_\" + name);\n      field.setOption(\"proto3_optional\", true);\n      oneof.add(field);\n      parent.add(oneof);\n    } else {\n      parent.add(field);\n    }\n    if (parent === ptr) {\n      topLevelObjects.push(field);\n    }\n  }\n  function parseGroup(parent, rule) {\n    if (edition >= 2023) {\n      throw illegal(\"group\");\n    }\n    var name = next();\n\n    /* istanbul ignore if */\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    var fieldName = util.lcFirst(name);\n    if (name === fieldName) name = util.ucFirst(name);\n    skip(\"=\");\n    var id = parseId(next());\n    var type = new Type(name);\n    type.group = true;\n    var field = new Field(fieldName, id, name, rule);\n    field.filename = parse.filename;\n    ifBlock(type, function parseGroup_block(token) {\n      switch (token) {\n        case \"option\":\n          parseOption(type, token);\n          skip(\";\");\n          break;\n        case \"required\":\n        case \"repeated\":\n          parseField(type, token);\n          break;\n        case \"optional\":\n          /* istanbul ignore if */\n          if (edition === \"proto3\") {\n            parseField(type, \"proto3_optional\");\n          } else {\n            parseField(type, \"optional\");\n          }\n          break;\n        case \"message\":\n          parseType(type, token);\n          break;\n        case \"enum\":\n          parseEnum(type, token);\n          break;\n        case \"reserved\":\n          readRanges(type.reserved || (type.reserved = []), true);\n          break;\n\n        /* istanbul ignore next */\n        default:\n          throw illegal(token);\n        // there are no groups with proto3 semantics\n      }\n    });\n    parent.add(type).add(field);\n  }\n  function parseMapField(parent) {\n    skip(\"<\");\n    var keyType = next();\n\n    /* istanbul ignore if */\n    if (types.mapKey[keyType] === undefined) throw illegal(keyType, \"type\");\n    skip(\",\");\n    var valueType = next();\n\n    /* istanbul ignore if */\n    if (!typeRefRe.test(valueType)) throw illegal(valueType, \"type\");\n    skip(\">\");\n    var name = next();\n\n    /* istanbul ignore if */\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    skip(\"=\");\n    var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n    ifBlock(field, function parseMapField_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(field, token);\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseMapField_line() {\n      parseInlineOptions(field);\n    });\n    parent.add(field);\n  }\n  function parseOneOf(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var oneof = new OneOf(applyCase(token));\n    ifBlock(oneof, function parseOneOf_block(token) {\n      if (token === \"option\") {\n        parseOption(oneof, token);\n        skip(\";\");\n      } else {\n        push(token);\n        parseField(oneof, \"optional\");\n      }\n    });\n    parent.add(oneof);\n  }\n  function parseEnum(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var enm = new Enum(token);\n    ifBlock(enm, function parseEnum_block(token) {\n      switch (token) {\n        case \"option\":\n          parseOption(enm, token);\n          skip(\";\");\n          break;\n        case \"reserved\":\n          readRanges(enm.reserved || (enm.reserved = []), true);\n          if (enm.reserved === undefined) enm.reserved = [];\n          break;\n        default:\n          parseEnumValue(enm, token);\n      }\n    });\n    parent.add(enm);\n    if (parent === ptr) {\n      topLevelObjects.push(enm);\n    }\n  }\n  function parseEnumValue(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token)) throw illegal(token, \"name\");\n    skip(\"=\");\n    var value = parseId(next(), true),\n      dummy = {\n        options: undefined\n      };\n    dummy.getOption = function (name) {\n      return this.options[name];\n    };\n    dummy.setOption = function (name, value) {\n      ReflectionObject.prototype.setOption.call(dummy, name, value);\n    };\n    dummy.setParsedOption = function () {\n      return undefined;\n    };\n    ifBlock(dummy, function parseEnumValue_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(dummy, token); // skip\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseEnumValue_line() {\n      parseInlineOptions(dummy); // skip\n    });\n    parent.add(token, value, dummy.comment, dummy.parsedOptions || dummy.options);\n  }\n  function parseOption(parent, token) {\n    var option;\n    var propName;\n    var isOption = true;\n    if (token === \"option\") {\n      token = next();\n    }\n    while (token !== \"=\") {\n      if (token === \"(\") {\n        var parensValue = next();\n        skip(\")\");\n        token = \"(\" + parensValue + \")\";\n      }\n      if (isOption) {\n        isOption = false;\n        if (token.includes(\".\") && !token.includes(\"(\")) {\n          var tokens = token.split(\".\");\n          option = tokens[0] + \".\";\n          token = tokens[1];\n          continue;\n        }\n        option = token;\n      } else {\n        propName = propName ? propName += token : token;\n      }\n      token = next();\n    }\n    var name = propName ? option.concat(propName) : option;\n    var optionValue = parseOptionValue(parent, name);\n    propName = propName && propName[0] === \".\" ? propName.slice(1) : propName;\n    option = option && option[option.length - 1] === \".\" ? option.slice(0, -1) : option;\n    setParsedOption(parent, option, optionValue, propName);\n  }\n  function parseOptionValue(parent, name) {\n    // { a: \"foo\" b { c: \"bar\" } }\n    if (skip(\"{\", true)) {\n      var objectResult = {};\n      while (!skip(\"}\", true)) {\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next())) {\n          throw illegal(token, \"name\");\n        }\n        if (token === null) {\n          throw illegal(token, \"end of input\");\n        }\n        var value;\n        var propName = token;\n        skip(\":\", true);\n        if (peek() === \"{\") {\n          // option (my_option) = {\n          //     repeated_value: [ \"foo\", \"bar\" ]\n          // };\n          value = parseOptionValue(parent, name + \".\" + token);\n        } else if (peek() === \"[\") {\n          value = [];\n          var lastValue;\n          if (skip(\"[\", true)) {\n            do {\n              lastValue = readValue(true);\n              value.push(lastValue);\n            } while (skip(\",\", true));\n            skip(\"]\");\n            if (typeof lastValue !== \"undefined\") {\n              setOption(parent, name + \".\" + token, lastValue);\n            }\n          }\n        } else {\n          value = readValue(true);\n          setOption(parent, name + \".\" + token, value);\n        }\n        var prevValue = objectResult[propName];\n        if (prevValue) value = [].concat(prevValue).concat(value);\n        objectResult[propName] = value;\n\n        // Semicolons and commas can be optional\n        skip(\",\", true);\n        skip(\";\", true);\n      }\n      return objectResult;\n    }\n    var simpleValue = readValue(true);\n    setOption(parent, name, simpleValue);\n    return simpleValue;\n    // Does not enforce a delimiter to be universal\n  }\n  function setOption(parent, name, value) {\n    if (ptr === parent && /^features\\./.test(name)) {\n      topLevelOptions[name] = value;\n      return;\n    }\n    if (parent.setOption) parent.setOption(name, value);\n  }\n  function setParsedOption(parent, name, value, propName) {\n    if (parent.setParsedOption) parent.setParsedOption(name, value, propName);\n  }\n  function parseInlineOptions(parent) {\n    if (skip(\"[\", true)) {\n      do {\n        parseOption(parent, \"option\");\n      } while (skip(\",\", true));\n      skip(\"]\");\n    }\n    return parent;\n  }\n  function parseService(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"service name\");\n    var service = new Service(token);\n    ifBlock(service, function parseService_block(token) {\n      if (parseCommon(service, token)) {\n        return;\n      }\n\n      /* istanbul ignore else */\n      if (token === \"rpc\") parseMethod(service, token);else throw illegal(token);\n    });\n    parent.add(service);\n    if (parent === ptr) {\n      topLevelObjects.push(service);\n    }\n  }\n  function parseMethod(parent, token) {\n    // Get the comment of the preceding line now (if one exists) in case the\n    // method is defined across multiple lines.\n    var commentText = cmnt();\n    var type = token;\n\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var name = token,\n      requestType,\n      requestStream,\n      responseType,\n      responseStream;\n    skip(\"(\");\n    if (skip(\"stream\", true)) requestStream = true;\n\n    /* istanbul ignore if */\n    if (!typeRefRe.test(token = next())) throw illegal(token);\n    requestType = token;\n    skip(\")\");\n    skip(\"returns\");\n    skip(\"(\");\n    if (skip(\"stream\", true)) responseStream = true;\n\n    /* istanbul ignore if */\n    if (!typeRefRe.test(token = next())) throw illegal(token);\n    responseType = token;\n    skip(\")\");\n    var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n    method.comment = commentText;\n    ifBlock(method, function parseMethod_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(method, token);\n        skip(\";\");\n      } else throw illegal(token);\n    });\n    parent.add(method);\n  }\n  function parseExtension(parent, token) {\n    /* istanbul ignore if */\n    if (!typeRefRe.test(token = next())) throw illegal(token, \"reference\");\n    var reference = token;\n    ifBlock(null, function parseExtension_block(token) {\n      switch (token) {\n        case \"required\":\n        case \"repeated\":\n          parseField(parent, token, reference);\n          break;\n        case \"optional\":\n          /* istanbul ignore if */\n          if (edition === \"proto3\") {\n            parseField(parent, \"proto3_optional\", reference);\n          } else {\n            parseField(parent, \"optional\", reference);\n          }\n          break;\n        default:\n          /* istanbul ignore if */\n          if (edition === \"proto2\" || !typeRefRe.test(token)) throw illegal(token);\n          push(token);\n          parseField(parent, \"optional\", reference);\n          break;\n      }\n    });\n  }\n  var token;\n  while ((token = next()) !== null) {\n    switch (token) {\n      case \"package\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parsePackage();\n        break;\n      case \"import\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parseImport();\n        break;\n      case \"syntax\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parseSyntax();\n        break;\n      case \"edition\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parseEdition();\n        break;\n      case \"option\":\n        parseOption(ptr, token);\n        skip(\";\", true);\n        break;\n      default:\n        /* istanbul ignore else */\n        if (parseCommon(ptr, token)) {\n          head = false;\n          continue;\n        }\n\n        /* istanbul ignore next */\n        throw illegal(token);\n    }\n  }\n  resolveFileFeatures();\n  parse.filename = null;\n  return {\n    \"package\": pkg,\n    \"imports\": imports,\n    weakImports: weakImports,\n    root: root\n  };\n}\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @name parse\n * @function\n * @param {string} source Source contents\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n * @variation 2\n */","map":{"version":3,"names":["module","exports","parse","filename","defaults","keepCase","tokenize","require","Root","Type","Field","MapField","OneOf","Enum","Service","Method","ReflectionObject","types","util","base10Re","base10NegRe","base16Re","base16NegRe","base8Re","base8NegRe","numberRe","nameRe","typeRefRe","source","root","options","preferTrailingComment","tn","alternateCommentMode","next","push","peek","skip","cmnt","head","pkg","imports","weakImports","edition","ptr","topLevelObjects","topLevelOptions","applyCase","name","camelCase","resolveFileFeatures","forEach","obj","_edition","Object","keys","opt","getOption","undefined","setOption","illegal","token","insideTryCatch","Error","line","readString","values","join","readValue","acceptTypeRef","parseNumber","e","test","readRanges","target","acceptStrings","start","str","parseId","err","dummy","value","ifBlock","parseRange_block","parseOption","parseRange_line","parseInlineOptions","sign","charAt","substring","Infinity","NaN","parseInt","parseFloat","acceptNegative","parsePackage","define","parseImport","whichImports","parseSyntax","parseEdition","supportedEditions","includes","parseCommon","parent","parseType","parseEnum","parseService","parseExtension","fnIf","fnElse","trailingLine","comment","type","parseType_block","parseMapField","parseField","parseOneOf","extensions","reserved","add","rule","extend","parseGroup","endsWith","startsWith","field","parseField_block","parseField_line","oneof","fieldName","lcFirst","ucFirst","id","group","parseGroup_block","keyType","mapKey","valueType","parseMapField_block","parseMapField_line","parseOneOf_block","enm","parseEnum_block","parseEnumValue","prototype","call","setParsedOption","parseEnumValue_block","parseEnumValue_line","parsedOptions","option","propName","isOption","parensValue","tokens","split","concat","optionValue","parseOptionValue","slice","length","objectResult","lastValue","prevValue","simpleValue","service","parseService_block","parseMethod","commentText","requestType","requestStream","responseType","responseStream","method","parseMethod_block","reference","parseExtension_block"],"sources":["/home/linux-1/projects/web-server-app/imx8mp-web-client/node_modules/protobufjs/src/parse.js"],"sourcesContent":["\"use strict\";\nmodule.exports = parse;\n\nparse.filename = null;\nparse.defaults = { keepCase: false };\n\nvar tokenize  = require(\"./tokenize\"),\n    Root      = require(\"./root\"),\n    Type      = require(\"./type\"),\n    Field     = require(\"./field\"),\n    MapField  = require(\"./mapfield\"),\n    OneOf     = require(\"./oneof\"),\n    Enum      = require(\"./enum\"),\n    Service   = require(\"./service\"),\n    Method    = require(\"./method\"),\n    ReflectionObject = require(\"./object\"),\n    types     = require(\"./types\"),\n    util      = require(\"./util\");\n\nvar base10Re    = /^[1-9][0-9]*$/,\n    base10NegRe = /^-?[1-9][0-9]*$/,\n    base16Re    = /^0[x][0-9a-fA-F]+$/,\n    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\n    base8Re     = /^0[0-7]+$/,\n    base8NegRe  = /^-?0[0-7]+$/,\n    numberRe    = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\n    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n    typeRefRe   = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;\n\n/**\n * Result object returned from {@link parse}.\n * @interface IParserResult\n * @property {string|undefined} package Package name, if declared\n * @property {string[]|undefined} imports Imports, if any\n * @property {string[]|undefined} weakImports Weak imports, if any\n * @property {Root} root Populated root instance\n */\n\n/**\n * Options modifying the behavior of {@link parse}.\n * @interface IParseOptions\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\n */\n\n/**\n * Options modifying the behavior of JSON serialization.\n * @interface IToJSONOptions\n * @property {boolean} [keepComments=false] Serializes comments.\n */\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @param {string} source Source contents\n * @param {Root} root Root to populate\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n */\nfunction parse(source, root, options) {\n    /* eslint-disable callback-return */\n    if (!(root instanceof Root)) {\n        options = root;\n        root = new Root();\n    }\n    if (!options)\n        options = parse.defaults;\n\n    var preferTrailingComment = options.preferTrailingComment || false;\n    var tn = tokenize(source, options.alternateCommentMode || false),\n        next = tn.next,\n        push = tn.push,\n        peek = tn.peek,\n        skip = tn.skip,\n        cmnt = tn.cmnt;\n\n    var head = true,\n        pkg,\n        imports,\n        weakImports,\n        edition = \"proto2\";\n\n    var ptr = root;\n\n    var topLevelObjects = [];\n    var topLevelOptions = {};\n\n    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;\n\n    function resolveFileFeatures() {\n        topLevelObjects.forEach(obj => {\n            obj._edition = edition;\n            Object.keys(topLevelOptions).forEach(opt => {\n                if (obj.getOption(opt) !== undefined) return;\n                obj.setOption(opt, topLevelOptions[opt], true);\n            });\n        });\n    }\n\n    /* istanbul ignore next */\n    function illegal(token, name, insideTryCatch) {\n        var filename = parse.filename;\n        if (!insideTryCatch)\n            parse.filename = null;\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n    }\n\n    function readString() {\n        var values = [],\n            token;\n        do {\n            /* istanbul ignore if */\n            if ((token = next()) !== \"\\\"\" && token !== \"'\")\n                throw illegal(token);\n\n            values.push(next());\n            skip(token);\n            token = peek();\n        } while (token === \"\\\"\" || token === \"'\");\n        return values.join(\"\");\n    }\n\n    function readValue(acceptTypeRef) {\n        var token = next();\n        switch (token) {\n            case \"'\":\n            case \"\\\"\":\n                push(token);\n                return readString();\n            case \"true\": case \"TRUE\":\n                return true;\n            case \"false\": case \"FALSE\":\n                return false;\n        }\n        try {\n            return parseNumber(token, /* insideTryCatch */ true);\n        } catch (e) {\n            /* istanbul ignore else */\n            if (acceptTypeRef && typeRefRe.test(token))\n                return token;\n\n            /* istanbul ignore next */\n            throw illegal(token, \"value\");\n        }\n    }\n\n    function readRanges(target, acceptStrings) {\n        var token, start;\n        do {\n            if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\")) {\n                var str = readString();\n                target.push(str);\n                if (edition >= 2023) {\n                    throw illegal(str, \"id\");\n                }\n            } else {\n                try {\n                    target.push([ start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start ]);\n                } catch (err) {\n                    if (acceptStrings && typeRefRe.test(token) && edition >= 2023) {\n                        target.push(token);\n                    } else {\n                        throw err;\n                    }\n                }\n            }\n        } while (skip(\",\", true));\n        var dummy = {options: undefined};\n        dummy.setOption = function(name, value) {\n          if (this.options === undefined) this.options = {};\n          this.options[name] = value;\n        };\n        ifBlock(\n            dummy,\n            function parseRange_block(token) {\n              /* istanbul ignore else */\n              if (token === \"option\") {\n                parseOption(dummy, token);  // skip\n                skip(\";\");\n              } else\n                throw illegal(token);\n            },\n            function parseRange_line() {\n              parseInlineOptions(dummy);  // skip\n            });\n    }\n\n    function parseNumber(token, insideTryCatch) {\n        var sign = 1;\n        if (token.charAt(0) === \"-\") {\n            sign = -1;\n            token = token.substring(1);\n        }\n        switch (token) {\n            case \"inf\": case \"INF\": case \"Inf\":\n                return sign * Infinity;\n            case \"nan\": case \"NAN\": case \"Nan\": case \"NaN\":\n                return NaN;\n            case \"0\":\n                return 0;\n        }\n        if (base10Re.test(token))\n            return sign * parseInt(token, 10);\n        if (base16Re.test(token))\n            return sign * parseInt(token, 16);\n        if (base8Re.test(token))\n            return sign * parseInt(token, 8);\n\n        /* istanbul ignore else */\n        if (numberRe.test(token))\n            return sign * parseFloat(token);\n\n        /* istanbul ignore next */\n        throw illegal(token, \"number\", insideTryCatch);\n    }\n\n    function parseId(token, acceptNegative) {\n        switch (token) {\n            case \"max\": case \"MAX\": case \"Max\":\n                return 536870911;\n            case \"0\":\n                return 0;\n        }\n\n        /* istanbul ignore if */\n        if (!acceptNegative && token.charAt(0) === \"-\")\n            throw illegal(token, \"id\");\n\n        if (base10NegRe.test(token))\n            return parseInt(token, 10);\n        if (base16NegRe.test(token))\n            return parseInt(token, 16);\n\n        /* istanbul ignore else */\n        if (base8NegRe.test(token))\n            return parseInt(token, 8);\n\n        /* istanbul ignore next */\n        throw illegal(token, \"id\");\n    }\n\n    function parsePackage() {\n        /* istanbul ignore if */\n        if (pkg !== undefined)\n            throw illegal(\"package\");\n\n        pkg = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(pkg))\n            throw illegal(pkg, \"name\");\n\n        ptr = ptr.define(pkg);\n\n        skip(\";\");\n    }\n\n    function parseImport() {\n        var token = peek();\n        var whichImports;\n        switch (token) {\n            case \"weak\":\n                whichImports = weakImports || (weakImports = []);\n                next();\n                break;\n            case \"public\":\n                next();\n                // eslint-disable-next-line no-fallthrough\n            default:\n                whichImports = imports || (imports = []);\n                break;\n        }\n        token = readString();\n        skip(\";\");\n        whichImports.push(token);\n    }\n\n    function parseSyntax() {\n        skip(\"=\");\n        edition = readString();\n\n        /* istanbul ignore if */\n        if (edition < 2023)\n            throw illegal(edition, \"syntax\");\n\n        skip(\";\");\n    }\n\n    function parseEdition() {\n        skip(\"=\");\n        edition = readString();\n        const supportedEditions = [\"2023\"];\n\n        /* istanbul ignore if */\n        if (!supportedEditions.includes(edition))\n            throw illegal(edition, \"edition\");\n\n        skip(\";\");\n    }\n\n\n    function parseCommon(parent, token) {\n        switch (token) {\n\n            case \"option\":\n                parseOption(parent, token);\n                skip(\";\");\n                return true;\n\n            case \"message\":\n                parseType(parent, token);\n                return true;\n\n            case \"enum\":\n                parseEnum(parent, token);\n                return true;\n\n            case \"service\":\n                parseService(parent, token);\n                return true;\n\n            case \"extend\":\n                parseExtension(parent, token);\n                return true;\n        }\n        return false;\n    }\n\n    function ifBlock(obj, fnIf, fnElse) {\n        var trailingLine = tn.line;\n        if (obj) {\n            if(typeof obj.comment !== \"string\") {\n              obj.comment = cmnt(); // try block-type comment\n            }\n            obj.filename = parse.filename;\n        }\n        if (skip(\"{\", true)) {\n            var token;\n            while ((token = next()) !== \"}\")\n                fnIf(token);\n            skip(\";\", true);\n        } else {\n            if (fnElse)\n                fnElse();\n            skip(\";\");\n            if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment))\n                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\n        }\n    }\n\n    function parseType(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"type name\");\n\n        var type = new Type(token);\n        ifBlock(type, function parseType_block(token) {\n            if (parseCommon(type, token))\n                return;\n\n            switch (token) {\n\n                case \"map\":\n                    parseMapField(type, token);\n                    break;\n\n                case \"required\":\n                    if (edition !== \"proto2\")\n                        throw illegal(token);\n                /* eslint-disable no-fallthrough */\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (edition === \"proto3\") {\n                        parseField(type, \"proto3_optional\");\n                    } else if (edition !== \"proto2\") {\n                        throw illegal(token);\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n\n                case \"oneof\":\n                    parseOneOf(type, token);\n                    break;\n\n                case \"extensions\":\n                    readRanges(type.extensions || (type.extensions = []));\n                    break;\n\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n\n                default:\n                    /* istanbul ignore if */\n                    if (edition === \"proto2\" || !typeRefRe.test(token)) {\n                        throw illegal(token);\n                    }\n\n                    push(token);\n                    parseField(type, \"optional\");\n                    break;\n            }\n        });\n        parent.add(type);\n        if (parent === ptr) {\n            topLevelObjects.push(type);\n        }\n    }\n\n    function parseField(parent, rule, extend) {\n        var type = next();\n        if (type === \"group\") {\n            parseGroup(parent, rule);\n            return;\n        }\n        // Type names can consume multiple tokens, in multiple variants:\n        //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        // Keep reading tokens until we get a type name with no period at the end,\n        // and the next token does not start with a period.\n        while (type.endsWith(\".\") || peek().startsWith(\".\")) {\n            type += next();\n        }\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(type))\n            throw illegal(type, \"type\");\n\n        var name = next();\n\n        /* istanbul ignore if */\n\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        name = applyCase(name);\n        skip(\"=\");\n\n        var field = new Field(name, parseId(next()), type, rule, extend);\n\n        ifBlock(field, function parseField_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseField_line() {\n            parseInlineOptions(field);\n        });\n\n        if (rule === \"proto3_optional\") {\n            // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\n            var oneof = new OneOf(\"_\" + name);\n            field.setOption(\"proto3_optional\", true);\n            oneof.add(field);\n            parent.add(oneof);\n        } else {\n            parent.add(field);\n        }\n        if (parent === ptr) {\n            topLevelObjects.push(field);\n        }\n    }\n\n    function parseGroup(parent, rule) {\n        if (edition >= 2023) {\n            throw illegal(\"group\");\n        }\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        var fieldName = util.lcFirst(name);\n        if (name === fieldName)\n            name = util.ucFirst(name);\n        skip(\"=\");\n        var id = parseId(next());\n        var type = new Type(name);\n        type.group = true;\n        var field = new Field(fieldName, id, name, rule);\n        field.filename = parse.filename;\n        ifBlock(type, function parseGroup_block(token) {\n            switch (token) {\n\n                case \"option\":\n                    parseOption(type, token);\n                    skip(\";\");\n                    break;\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (edition === \"proto3\") {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n\n                case \"message\":\n                    parseType(type, token);\n                    break;\n\n                case \"enum\":\n                    parseEnum(type, token);\n                    break;\n\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n\n                /* istanbul ignore next */\n                default:\n                    throw illegal(token); // there are no groups with proto3 semantics\n            }\n        });\n        parent.add(type)\n              .add(field);\n    }\n\n    function parseMapField(parent) {\n        skip(\"<\");\n        var keyType = next();\n\n        /* istanbul ignore if */\n        if (types.mapKey[keyType] === undefined)\n            throw illegal(keyType, \"type\");\n\n        skip(\",\");\n        var valueType = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(valueType))\n            throw illegal(valueType, \"type\");\n\n        skip(\">\");\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        skip(\"=\");\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n        ifBlock(field, function parseMapField_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseMapField_line() {\n            parseInlineOptions(field);\n        });\n        parent.add(field);\n    }\n\n    function parseOneOf(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var oneof = new OneOf(applyCase(token));\n        ifBlock(oneof, function parseOneOf_block(token) {\n            if (token === \"option\") {\n                parseOption(oneof, token);\n                skip(\";\");\n            } else {\n                push(token);\n                parseField(oneof, \"optional\");\n            }\n        });\n        parent.add(oneof);\n    }\n\n    function parseEnum(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var enm = new Enum(token);\n        ifBlock(enm, function parseEnum_block(token) {\n          switch(token) {\n            case \"option\":\n              parseOption(enm, token);\n              skip(\";\");\n              break;\n\n            case \"reserved\":\n              readRanges(enm.reserved || (enm.reserved = []), true);\n              if(enm.reserved === undefined) enm.reserved = [];\n              break;\n\n            default:\n              parseEnumValue(enm, token);\n          }\n        });\n        parent.add(enm);\n        if (parent === ptr) {\n            topLevelObjects.push(enm);\n        }\n    }\n\n    function parseEnumValue(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token))\n            throw illegal(token, \"name\");\n\n        skip(\"=\");\n        var value = parseId(next(), true),\n            dummy = {\n                options: undefined\n            };\n        dummy.getOption = function(name) {\n            return this.options[name];\n        };\n        dummy.setOption = function(name, value) {\n            ReflectionObject.prototype.setOption.call(dummy, name, value);\n        };\n        dummy.setParsedOption = function() {\n            return undefined;\n        };\n        ifBlock(dummy, function parseEnumValue_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(dummy, token); // skip\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseEnumValue_line() {\n            parseInlineOptions(dummy); // skip\n        });\n        parent.add(token, value, dummy.comment, dummy.parsedOptions || dummy.options);\n    }\n\n    function parseOption(parent, token) {\n            var option;\n            var propName;\n            var isOption = true;\n            if (token === \"option\") {\n                token = next();\n            }\n\n            while (token !== \"=\") {\n                if (token === \"(\") {\n                    var parensValue = next();\n                    skip(\")\");\n                    token = \"(\" + parensValue + \")\";\n                }\n                if (isOption) {\n                    isOption = false;\n                    if (token.includes(\".\") && !token.includes(\"(\")) {\n                        var tokens = token.split(\".\");\n                        option = tokens[0] + \".\";\n                        token = tokens[1];\n                        continue;\n                    }\n                    option = token;\n                } else {\n                    propName = propName ? propName += token : token;\n                }\n                token = next();\n            }\n            var name = propName ? option.concat(propName) : option;\n            var optionValue = parseOptionValue(parent, name);\n            propName = propName && propName[0] === \".\" ? propName.slice(1) : propName;\n            option = option && option[option.length - 1] === \".\" ? option.slice(0, -1) : option;\n            setParsedOption(parent, option, optionValue, propName);\n    }\n\n    function parseOptionValue(parent, name) {\n        // { a: \"foo\" b { c: \"bar\" } }\n        if (skip(\"{\", true)) {\n            var objectResult = {};\n\n            while (!skip(\"}\", true)) {\n                /* istanbul ignore if */\n                if (!nameRe.test(token = next())) {\n                    throw illegal(token, \"name\");\n                }\n                if (token === null) {\n                  throw illegal(token, \"end of input\");\n                }\n\n                var value;\n                var propName = token;\n\n                skip(\":\", true);\n\n                if (peek() === \"{\") {\n                    // option (my_option) = {\n                    //     repeated_value: [ \"foo\", \"bar\" ]\n                    // };\n                    value = parseOptionValue(parent, name + \".\" + token);\n                } else if (peek() === \"[\") {\n                    value = [];\n                    var lastValue;\n                    if (skip(\"[\", true)) {\n                        do {\n                            lastValue = readValue(true);\n                            value.push(lastValue);\n                        } while (skip(\",\", true));\n                        skip(\"]\");\n                        if (typeof lastValue !== \"undefined\") {\n                            setOption(parent, name + \".\" + token, lastValue);\n                        }\n                    }\n                } else {\n                    value = readValue(true);\n                    setOption(parent, name + \".\" + token, value);\n                }\n\n                var prevValue = objectResult[propName];\n\n                if (prevValue)\n                    value = [].concat(prevValue).concat(value);\n\n                objectResult[propName] = value;\n\n                // Semicolons and commas can be optional\n                skip(\",\", true);\n                skip(\";\", true);\n            }\n\n            return objectResult;\n        }\n\n        var simpleValue = readValue(true);\n        setOption(parent, name, simpleValue);\n        return simpleValue;\n        // Does not enforce a delimiter to be universal\n    }\n\n    function setOption(parent, name, value) {\n        if (ptr === parent && /^features\\./.test(name)) {\n            topLevelOptions[name] = value;\n            return;\n        }\n        if (parent.setOption)\n            parent.setOption(name, value);\n    }\n\n    function setParsedOption(parent, name, value, propName) {\n        if (parent.setParsedOption)\n            parent.setParsedOption(name, value, propName);\n    }\n\n    function parseInlineOptions(parent) {\n        if (skip(\"[\", true)) {\n            do {\n                parseOption(parent, \"option\");\n            } while (skip(\",\", true));\n            skip(\"]\");\n        }\n        return parent;\n    }\n\n    function parseService(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"service name\");\n\n        var service = new Service(token);\n        ifBlock(service, function parseService_block(token) {\n            if (parseCommon(service, token)) {\n                return;\n            }\n\n            /* istanbul ignore else */\n            if (token === \"rpc\")\n                parseMethod(service, token);\n            else\n                throw illegal(token);\n        });\n        parent.add(service);\n        if (parent === ptr) {\n            topLevelObjects.push(service);\n        }\n    }\n\n    function parseMethod(parent, token) {\n        // Get the comment of the preceding line now (if one exists) in case the\n        // method is defined across multiple lines.\n        var commentText = cmnt();\n\n        var type = token;\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var name = token,\n            requestType, requestStream,\n            responseType, responseStream;\n\n        skip(\"(\");\n        if (skip(\"stream\", true))\n            requestStream = true;\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token);\n\n        requestType = token;\n        skip(\")\"); skip(\"returns\"); skip(\"(\");\n        if (skip(\"stream\", true))\n            responseStream = true;\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token);\n\n        responseType = token;\n        skip(\")\");\n\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n        method.comment = commentText;\n        ifBlock(method, function parseMethod_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(method, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        });\n        parent.add(method);\n    }\n\n    function parseExtension(parent, token) {\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token, \"reference\");\n\n        var reference = token;\n        ifBlock(null, function parseExtension_block(token) {\n            switch (token) {\n\n                case \"required\":\n                case \"repeated\":\n                    parseField(parent, token, reference);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (edition === \"proto3\") {\n                        parseField(parent, \"proto3_optional\", reference);\n                    } else {\n                        parseField(parent, \"optional\", reference);\n                    }\n                    break;\n\n                default:\n                    /* istanbul ignore if */\n                    if (edition === \"proto2\" || !typeRefRe.test(token))\n                        throw illegal(token);\n                    push(token);\n                    parseField(parent, \"optional\", reference);\n                    break;\n            }\n        });\n    }\n\n    var token;\n    while ((token = next()) !== null) {\n        switch (token) {\n\n            case \"package\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parsePackage();\n                break;\n\n            case \"import\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parseImport();\n                break;\n\n            case \"syntax\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parseSyntax();\n                break;\n\n            case \"edition\":\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n                parseEdition();\n                break;\n\n            case \"option\":\n                parseOption(ptr, token);\n                skip(\";\", true);\n                break;\n\n            default:\n\n                /* istanbul ignore else */\n                if (parseCommon(ptr, token)) {\n                    head = false;\n                    continue;\n                }\n\n                /* istanbul ignore next */\n                throw illegal(token);\n        }\n    }\n\n    resolveFileFeatures();\n\n    parse.filename = null;\n    return {\n        \"package\"     : pkg,\n        \"imports\"     : imports,\n         weakImports  : weakImports,\n         root         : root\n    };\n}\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @name parse\n * @function\n * @param {string} source Source contents\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n * @variation 2\n */\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}