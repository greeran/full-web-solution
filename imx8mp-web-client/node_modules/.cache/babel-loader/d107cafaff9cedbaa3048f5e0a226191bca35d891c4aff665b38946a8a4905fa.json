{"ast":null,"code":"import mqtt from 'mqtt';\nimport * as fileops from '../types/fileops_pb';\nimport { protobufService } from './protobufService';\nclass MQTTService {\n  constructor() {\n    this.client = null;\n    this.config = null;\n    this.sensorData = {};\n    this.listeners = [];\n    this.fileUploadResultListener = null;\n  }\n  async connect(config) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        await protobufService.initialize();\n        this.config = config;\n        const url = `ws://${config.host}:8083`;\n        this.client = mqtt.connect(url, {\n          clientId: config.client_id,\n          clean: true,\n          connectTimeout: 4000,\n          reconnectPeriod: 1000\n        });\n        this.client.on('connect', () => {\n          this.subscribeToTopics();\n          resolve();\n        });\n        this.client.on('message', (topic, message) => {\n          this.handleMessage(topic, message);\n        });\n        this.client.on('error', error => {\n          reject(error);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  subscribeToTopics() {\n    if (!this.client || !this.config) return;\n    Object.entries(this.config.topics).forEach(([key, topicConfig]) => {\n      this.client.subscribe(topicConfig.topic);\n    });\n  }\n  handleMessage(topic, message) {\n    // Handle file upload result topic\n    if (topic === 'uploads/success' && this.fileUploadResultListener) {\n      try {\n        const result = fileops.decodeFileUploadResult(message);\n        this.fileUploadResultListener(result);\n      } catch (e) {\n        console.error('Failed to decode FileUploadResult:', e);\n      }\n      return;\n    }\n    // Handle sensor topics\n    if (topic.startsWith('sensor/')) {\n      const parsed = protobufService.parseMessage(topic, message);\n      if (parsed) {\n        // Use the last part of the topic as the sensor key (e.g., 'temperature' from 'sensor/temperature')\n        const sensorKey = topic.split('/')[1];\n        this.sensorData[sensorKey] = parsed;\n        this.listeners.forEach(cb => cb({\n          ...this.sensorData\n        }));\n      }\n    }\n  }\n\n  // --- File Upload via MQTT ---\n  async uploadFileViaMQTT(file, uploadDirectory, allowedExtensions, publishTopic, returnTopic) {\n    if (!this.client) throw new Error('MQTT client not connected');\n    const extension = file.name.substring(file.name.lastIndexOf('.'));\n    if (!allowedExtensions.includes(extension)) {\n      throw new Error('File extension not allowed');\n    }\n    const arrayBuffer = await file.arrayBuffer();\n    const payload = fileops.encodeFileUploadRequest({\n      filename: file.name,\n      extension,\n      file_data: new Uint8Array(arrayBuffer),\n      upload_directory: uploadDirectory\n    });\n    // Publish the file upload request\n    this.client.publish(publishTopic, payload);\n    // Optionally subscribe to return topic and wait for result\n    if (returnTopic) {\n      return new Promise((resolve, reject) => {\n        this.fileUploadResultListener = result => {\n          this.client.unsubscribe(returnTopic);\n          this.fileUploadResultListener = null;\n          resolve(result);\n        };\n        this.client.subscribe(returnTopic);\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n  onSensorDataUpdate(callback) {\n    this.listeners.push(callback);\n  }\n  getSensorData() {\n    return {\n      ...this.sensorData\n    };\n  }\n  disconnect() {\n    if (this.client) {\n      this.client.end();\n      this.client = null;\n    }\n  }\n  isConnected() {\n    var _this$client;\n    return ((_this$client = this.client) === null || _this$client === void 0 ? void 0 : _this$client.connected) || false;\n  }\n}\nexport const mqttService = new MQTTService();","map":{"version":3,"names":["mqtt","fileops","protobufService","MQTTService","constructor","client","config","sensorData","listeners","fileUploadResultListener","connect","Promise","resolve","reject","initialize","url","host","clientId","client_id","clean","connectTimeout","reconnectPeriod","on","subscribeToTopics","topic","message","handleMessage","error","Object","entries","topics","forEach","key","topicConfig","subscribe","result","decodeFileUploadResult","e","console","startsWith","parsed","parseMessage","sensorKey","split","cb","uploadFileViaMQTT","file","uploadDirectory","allowedExtensions","publishTopic","returnTopic","Error","extension","name","substring","lastIndexOf","includes","arrayBuffer","payload","encodeFileUploadRequest","filename","file_data","Uint8Array","upload_directory","publish","unsubscribe","onSensorDataUpdate","callback","push","getSensorData","disconnect","end","isConnected","_this$client","connected","mqttService"],"sources":["/home/linux-1/projects/web-server-app/imx8mp-web-client/src/services/mqttService.ts"],"sourcesContent":["import mqtt, { MqttClient } from 'mqtt';\nimport { SensorData, MQTTConfig } from '../types';\nimport * as fileops from '../types/fileops_pb';\nimport { protobufService } from './protobufService';\n\nclass MQTTService {\n  private client: MqttClient | null = null;\n  private config: MQTTConfig | null = null;\n  private sensorData: { [key: string]: SensorData } = {};\n  private listeners: ((data: { [key: string]: SensorData }) => void)[] = [];\n  private fileUploadResultListener: ((result: any) => void) | null = null;\n\n  async connect(config: MQTTConfig): Promise<void> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        await protobufService.initialize();\n        this.config = config;\n        const url = `ws://${config.host}:8083`;\n        this.client = mqtt.connect(url, {\n          clientId: config.client_id,\n          clean: true,\n          connectTimeout: 4000,\n          reconnectPeriod: 1000,\n        });\n        this.client.on('connect', () => {\n          this.subscribeToTopics();\n          resolve();\n        });\n        this.client.on('message', (topic, message) => {\n          this.handleMessage(topic, message);\n        });\n        this.client.on('error', (error) => {\n          reject(error);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  private subscribeToTopics(): void {\n    if (!this.client || !this.config) return;\n    Object.entries(this.config.topics).forEach(([key, topicConfig]) => {\n      this.client!.subscribe(topicConfig.topic);\n    });\n  }\n\n  private handleMessage(topic: string, message: Buffer): void {\n    // Handle file upload result topic\n    if (topic === 'uploads/success' && this.fileUploadResultListener) {\n      try {\n        const result = fileops.decodeFileUploadResult(message);\n        this.fileUploadResultListener(result);\n      } catch (e) {\n        console.error('Failed to decode FileUploadResult:', e);\n      }\n      return;\n    }\n    // Handle sensor topics\n    if (topic.startsWith('sensor/')) {\n      const parsed = protobufService.parseMessage(topic, message);\n      if (parsed) {\n        // Use the last part of the topic as the sensor key (e.g., 'temperature' from 'sensor/temperature')\n        const sensorKey = topic.split('/')[1];\n        this.sensorData[sensorKey] = parsed;\n        this.listeners.forEach((cb) => cb({ ...this.sensorData }));\n      }\n    }\n  }\n\n  // --- File Upload via MQTT ---\n  async uploadFileViaMQTT(file: File, uploadDirectory: string, allowedExtensions: string[], publishTopic: string, returnTopic?: string): Promise<any> {\n    if (!this.client) throw new Error('MQTT client not connected');\n    const extension = file.name.substring(file.name.lastIndexOf('.'));\n    if (!allowedExtensions.includes(extension)) {\n      throw new Error('File extension not allowed');\n    }\n    const arrayBuffer = await file.arrayBuffer();\n    const payload = fileops.encodeFileUploadRequest({\n      filename: file.name,\n      extension,\n      file_data: new Uint8Array(arrayBuffer),\n      upload_directory: uploadDirectory,\n    });\n    // Publish the file upload request\n    this.client.publish(publishTopic, payload);\n    // Optionally subscribe to return topic and wait for result\n    if (returnTopic) {\n      return new Promise((resolve, reject) => {\n        this.fileUploadResultListener = (result) => {\n          this.client!.unsubscribe(returnTopic);\n          this.fileUploadResultListener = null;\n          resolve(result);\n        };\n        this.client!.subscribe(returnTopic);\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  onSensorDataUpdate(callback: (data: { [key: string]: SensorData }) => void): void {\n    this.listeners.push(callback);\n  }\n\n  getSensorData(): { [key: string]: SensorData } {\n    return { ...this.sensorData };\n  }\n\n  disconnect(): void {\n    if (this.client) {\n      this.client.end();\n      this.client = null;\n    }\n  }\n\n  isConnected(): boolean {\n    return this.client?.connected || false;\n  }\n}\n\nexport const mqttService = new MQTTService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}