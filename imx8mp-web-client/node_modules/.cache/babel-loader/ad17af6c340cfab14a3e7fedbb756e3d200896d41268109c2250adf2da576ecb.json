{"ast":null,"code":"\"use strict\";\n\nmodule.exports = ReflectionObject;\nReflectionObject.className = \"ReflectionObject\";\nconst OneOf = require(\"./oneof\");\nvar util = require(\"./util\");\nvar Root; // cyclic\n\n/* eslint-disable no-warning-comments */\n// TODO: Replace with embedded proto.\nvar editions2023Defaults = {\n  enum_type: \"OPEN\",\n  field_presence: \"EXPLICIT\",\n  json_format: \"ALLOW\",\n  message_encoding: \"LENGTH_PREFIXED\",\n  repeated_field_encoding: \"PACKED\",\n  utf8_validation: \"VERIFY\"\n};\nvar proto2Defaults = {\n  enum_type: \"CLOSED\",\n  field_presence: \"EXPLICIT\",\n  json_format: \"LEGACY_BEST_EFFORT\",\n  message_encoding: \"LENGTH_PREFIXED\",\n  repeated_field_encoding: \"EXPANDED\",\n  utf8_validation: \"NONE\"\n};\nvar proto3Defaults = {\n  enum_type: \"OPEN\",\n  field_presence: \"IMPLICIT\",\n  json_format: \"ALLOW\",\n  message_encoding: \"LENGTH_PREFIXED\",\n  repeated_field_encoding: \"PACKED\",\n  utf8_validation: \"VERIFY\"\n};\n\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */\nfunction ReflectionObject(name, options) {\n  if (!util.isString(name)) throw TypeError(\"name must be a string\");\n  if (options && !util.isObject(options)) throw TypeError(\"options must be an object\");\n\n  /**\n   * Options.\n   * @type {Object.<string,*>|undefined}\n   */\n  this.options = options; // toJSON\n\n  /**\n   * Parsed Options.\n   * @type {Array.<Object.<string,*>>|undefined}\n   */\n  this.parsedOptions = null;\n\n  /**\n   * Unique name within its namespace.\n   * @type {string}\n   */\n  this.name = name;\n\n  /**\n   * The edition specified for this object.  Only relevant for top-level objects.\n   * @type {string}\n   * @private\n   */\n  this._edition = null;\n\n  /**\n   * The default edition to use for this object if none is specified.  For legacy reasons,\n   * this is proto2 except in the JSON parsing case where it was proto3.\n   * @type {string}\n   * @private\n   */\n  this._defaultEdition = \"proto2\";\n\n  /**\n   * Resolved Features.\n   * @type {object}\n   * @private\n   */\n  this._features = {};\n\n  /**\n   * Whether or not features have been resolved.\n   * @type {boolean}\n   * @private\n   */\n  this._featuresResolved = false;\n\n  /**\n   * Parent namespace.\n   * @type {Namespace|null}\n   */\n  this.parent = null;\n\n  /**\n   * Whether already resolved or not.\n   * @type {boolean}\n   */\n  this.resolved = false;\n\n  /**\n   * Comment text, if any.\n   * @type {string|null}\n   */\n  this.comment = null;\n\n  /**\n   * Defining file name.\n   * @type {string|null}\n   */\n  this.filename = null;\n}\nObject.defineProperties(ReflectionObject.prototype, {\n  /**\n   * Reference to the root namespace.\n   * @name ReflectionObject#root\n   * @type {Root}\n   * @readonly\n   */\n  root: {\n    get: function () {\n      var ptr = this;\n      while (ptr.parent !== null) ptr = ptr.parent;\n      return ptr;\n    }\n  },\n  /**\n   * Full name including leading dot.\n   * @name ReflectionObject#fullName\n   * @type {string}\n   * @readonly\n   */\n  fullName: {\n    get: function () {\n      var path = [this.name],\n        ptr = this.parent;\n      while (ptr) {\n        path.unshift(ptr.name);\n        ptr = ptr.parent;\n      }\n      return path.join(\".\");\n    }\n  }\n});\n\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */\nReflectionObject.prototype.toJSON = /* istanbul ignore next */function toJSON() {\n  throw Error(); // not implemented, shouldn't happen\n};\n\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */\nReflectionObject.prototype.onAdd = function onAdd(parent) {\n  if (this.parent && this.parent !== parent) this.parent.remove(this);\n  this.parent = parent;\n  this.resolved = false;\n  var root = parent.root;\n  if (root instanceof Root) root._handleAdd(this);\n};\n\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */\nReflectionObject.prototype.onRemove = function onRemove(parent) {\n  var root = parent.root;\n  if (root instanceof Root) root._handleRemove(this);\n  this.parent = null;\n  this.resolved = false;\n};\n\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.resolve = function resolve() {\n  if (this.resolved) return this;\n  if (this.root instanceof Root) this.resolved = true; // only if part of a root\n  return this;\n};\n\n/**\n * Resolves this objects editions features.\n * @param {string} edition The edition we're currently resolving for.\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n  return this._resolveFeatures(this._edition || edition);\n};\n\n/**\n * Resolves child features from parent features\n * @param {string} edition The edition we're currently resolving for.\n * @returns {undefined}\n */\nReflectionObject.prototype._resolveFeatures = function _resolveFeatures(edition) {\n  if (this._featuresResolved) {\n    return;\n  }\n  var defaults = {};\n\n  /* istanbul ignore if */\n  if (!edition) {\n    throw new Error(\"Unknown edition for \" + this.fullName);\n  }\n  var protoFeatures = Object.assign(this.options ? Object.assign({}, this.options.features) : {}, this._inferLegacyProtoFeatures(edition));\n  if (this._edition) {\n    // For a namespace marked with a specific edition, reset defaults.\n    /* istanbul ignore else */\n    if (edition === \"proto2\") {\n      defaults = Object.assign({}, proto2Defaults);\n    } else if (edition === \"proto3\") {\n      defaults = Object.assign({}, proto3Defaults);\n    } else if (edition === \"2023\") {\n      defaults = Object.assign({}, editions2023Defaults);\n    } else {\n      throw new Error(\"Unknown edition: \" + edition);\n    }\n    this._features = Object.assign(defaults, protoFeatures || {});\n    this._featuresResolved = true;\n    return;\n  }\n\n  // fields in Oneofs aren't actually children of them, so we have to\n  // special-case it\n  /* istanbul ignore else */\n  if (this.partOf instanceof OneOf) {\n    var lexicalParentFeaturesCopy = Object.assign({}, this.partOf._features);\n    this._features = Object.assign(lexicalParentFeaturesCopy, protoFeatures || {});\n  } else if (this.declaringField) {\n    // Skip feature resolution of sister fields.\n  } else if (this.parent) {\n    var parentFeaturesCopy = Object.assign({}, this.parent._features);\n    this._features = Object.assign(parentFeaturesCopy, protoFeatures || {});\n  } else {\n    throw new Error(\"Unable to find a parent for \" + this.fullName);\n  }\n  if (this.extensionField) {\n    // Sister fields should have the same features as their extensions.\n    this.extensionField._features = this._features;\n  }\n  this._featuresResolved = true;\n};\n\n/**\n * Infers features from legacy syntax that may have been specified differently.\n * in older editions.\n * @param {string|undefined} edition The edition this proto is on, or undefined if pre-editions\n * @returns {object} The feature values to override\n */\nReflectionObject.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures(/*edition*/\n) {\n  return {};\n};\n\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */\nReflectionObject.prototype.getOption = function getOption(name) {\n  if (this.options) return this.options[name];\n  return undefined;\n};\n\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean|undefined} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n  if (!this.options) this.options = {};\n  if (/^features\\./.test(name)) {\n    util.setProperty(this.options, name, value, ifNotSet);\n  } else if (!ifNotSet || this.options[name] === undefined) {\n    if (this.getOption(name) !== value) this.resolved = false;\n    this.options[name] = value;\n  }\n  return this;\n};\n\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n  if (!this.parsedOptions) {\n    this.parsedOptions = [];\n  }\n  var parsedOptions = this.parsedOptions;\n  if (propName) {\n    // If setting a sub property of an option then try to merge it\n    // with an existing option\n    var opt = parsedOptions.find(function (opt) {\n      return Object.prototype.hasOwnProperty.call(opt, name);\n    });\n    if (opt) {\n      // If we found an existing option - just merge the property value\n      // (If it's a feature, will just write over)\n      var newValue = opt[name];\n      util.setProperty(newValue, propName, value);\n    } else {\n      // otherwise, create a new option, set its property and add it to the list\n      opt = {};\n      opt[name] = util.setProperty({}, propName, value);\n      parsedOptions.push(opt);\n    }\n  } else {\n    // Always create a new option when setting the value of the option itself\n    var newOpt = {};\n    newOpt[name] = value;\n    parsedOptions.push(newOpt);\n  }\n  return this;\n};\n\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n  if (options) for (var keys = Object.keys(options), i = 0; i < keys.length; ++i) this.setOption(keys[i], options[keys[i]], ifNotSet);\n  return this;\n};\n\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */\nReflectionObject.prototype.toString = function toString() {\n  var className = this.constructor.className,\n    fullName = this.fullName;\n  if (fullName.length) return className + \" \" + fullName;\n  return className;\n};\n\n/**\n * Converts the edition this object is pinned to for JSON format.\n * @returns {string|undefined} The edition string for JSON representation\n */\nReflectionObject.prototype._editionToJSON = function _editionToJSON() {\n  if (!this._edition || this._edition === \"proto3\") {\n    // Avoid emitting proto3 since we need to default to it for backwards\n    // compatibility anyway.\n    return undefined;\n  }\n  return this._edition;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function (Root_) {\n  Root = Root_;\n};","map":{"version":3,"names":["module","exports","ReflectionObject","className","OneOf","require","util","Root","editions2023Defaults","enum_type","field_presence","json_format","message_encoding","repeated_field_encoding","utf8_validation","proto2Defaults","proto3Defaults","name","options","isString","TypeError","isObject","parsedOptions","_edition","_defaultEdition","_features","_featuresResolved","parent","resolved","comment","filename","Object","defineProperties","prototype","root","get","ptr","fullName","path","unshift","join","toJSON","Error","onAdd","remove","_handleAdd","onRemove","_handleRemove","resolve","_resolveFeaturesRecursive","edition","_resolveFeatures","defaults","protoFeatures","assign","features","_inferLegacyProtoFeatures","partOf","lexicalParentFeaturesCopy","declaringField","parentFeaturesCopy","extensionField","getOption","undefined","setOption","value","ifNotSet","test","setProperty","setParsedOption","propName","opt","find","hasOwnProperty","call","newValue","push","newOpt","setOptions","keys","i","length","toString","constructor","_editionToJSON","_configure","Root_"],"sources":["/home/linux-1/projects/web-server-app/imx8mp-web-client/node_modules/protobufjs/src/object.js"],"sourcesContent":["\"use strict\";\nmodule.exports = ReflectionObject;\n\nReflectionObject.className = \"ReflectionObject\";\n\nconst OneOf = require(\"./oneof\");\nvar util = require(\"./util\");\n\nvar Root; // cyclic\n\n/* eslint-disable no-warning-comments */\n// TODO: Replace with embedded proto.\nvar editions2023Defaults = {enum_type: \"OPEN\", field_presence: \"EXPLICIT\", json_format: \"ALLOW\", message_encoding: \"LENGTH_PREFIXED\", repeated_field_encoding: \"PACKED\", utf8_validation: \"VERIFY\"};\nvar proto2Defaults = {enum_type: \"CLOSED\", field_presence: \"EXPLICIT\", json_format: \"LEGACY_BEST_EFFORT\", message_encoding: \"LENGTH_PREFIXED\", repeated_field_encoding: \"EXPANDED\", utf8_validation: \"NONE\"};\nvar proto3Defaults = {enum_type: \"OPEN\", field_presence: \"IMPLICIT\", json_format: \"ALLOW\", message_encoding: \"LENGTH_PREFIXED\", repeated_field_encoding: \"PACKED\", utf8_validation: \"VERIFY\"};\n\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */\nfunction ReflectionObject(name, options) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (options && !util.isObject(options))\n        throw TypeError(\"options must be an object\");\n\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */\n    this.options = options; // toJSON\n\n    /**\n     * Parsed Options.\n     * @type {Array.<Object.<string,*>>|undefined}\n     */\n    this.parsedOptions = null;\n\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * The edition specified for this object.  Only relevant for top-level objects.\n     * @type {string}\n     * @private\n     */\n    this._edition = null;\n\n    /**\n     * The default edition to use for this object if none is specified.  For legacy reasons,\n     * this is proto2 except in the JSON parsing case where it was proto3.\n     * @type {string}\n     * @private\n     */\n    this._defaultEdition = \"proto2\";\n\n    /**\n     * Resolved Features.\n     * @type {object}\n     * @private\n     */\n    this._features = {};\n\n    /**\n     * Whether or not features have been resolved.\n     * @type {boolean}\n     * @private\n     */\n    this._featuresResolved = false;\n\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */\n    this.parent = null;\n\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */\n    this.resolved = false;\n\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */\n    this.comment = null;\n\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */\n    this.filename = null;\n}\n\nObject.defineProperties(ReflectionObject.prototype, {\n\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */\n    root: {\n        get: function() {\n            var ptr = this;\n            while (ptr.parent !== null)\n                ptr = ptr.parent;\n            return ptr;\n        }\n    },\n\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */\n    fullName: {\n        get: function() {\n            var path = [ this.name ],\n                ptr = this.parent;\n            while (ptr) {\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */\nReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */\nReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent)\n        this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleAdd(this);\n};\n\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */\nReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n    if (this.root instanceof Root)\n        this.resolved = true; // only if part of a root\n    return this;\n};\n\n/**\n * Resolves this objects editions features.\n * @param {string} edition The edition we're currently resolving for.\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n    return this._resolveFeatures(this._edition || edition);\n};\n\n/**\n * Resolves child features from parent features\n * @param {string} edition The edition we're currently resolving for.\n * @returns {undefined}\n */\nReflectionObject.prototype._resolveFeatures = function _resolveFeatures(edition) {\n    if (this._featuresResolved) {\n        return;\n    }\n\n    var defaults = {};\n\n    /* istanbul ignore if */\n    if (!edition) {\n        throw new Error(\"Unknown edition for \" + this.fullName);\n    }\n\n    var protoFeatures = Object.assign(this.options ? Object.assign({},  this.options.features) : {},\n        this._inferLegacyProtoFeatures(edition));\n\n    if (this._edition) {\n        // For a namespace marked with a specific edition, reset defaults.\n        /* istanbul ignore else */\n        if (edition === \"proto2\") {\n            defaults = Object.assign({}, proto2Defaults);\n        } else if (edition === \"proto3\") {\n            defaults = Object.assign({}, proto3Defaults);\n        } else if (edition === \"2023\") {\n            defaults = Object.assign({}, editions2023Defaults);\n        } else {\n            throw new Error(\"Unknown edition: \" + edition);\n        }\n        this._features = Object.assign(defaults, protoFeatures || {});\n        this._featuresResolved = true;\n        return;\n    }\n\n    // fields in Oneofs aren't actually children of them, so we have to\n    // special-case it\n    /* istanbul ignore else */\n    if (this.partOf instanceof OneOf) {\n        var lexicalParentFeaturesCopy = Object.assign({}, this.partOf._features);\n        this._features = Object.assign(lexicalParentFeaturesCopy, protoFeatures || {});\n    } else if (this.declaringField) {\n        // Skip feature resolution of sister fields.\n    } else if (this.parent) {\n        var parentFeaturesCopy = Object.assign({}, this.parent._features);\n        this._features = Object.assign(parentFeaturesCopy, protoFeatures || {});\n    } else {\n        throw new Error(\"Unable to find a parent for \" + this.fullName);\n    }\n    if (this.extensionField) {\n        // Sister fields should have the same features as their extensions.\n        this.extensionField._features = this._features;\n    }\n    this._featuresResolved = true;\n};\n\n/**\n * Infers features from legacy syntax that may have been specified differently.\n * in older editions.\n * @param {string|undefined} edition The edition this proto is on, or undefined if pre-editions\n * @returns {object} The feature values to override\n */\nReflectionObject.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures(/*edition*/) {\n    return {};\n};\n\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */\nReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options)\n        return this.options[name];\n    return undefined;\n};\n\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean|undefined} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!this.options)\n        this.options = {};\n    if (/^features\\./.test(name)) {\n        util.setProperty(this.options, name, value, ifNotSet);\n    } else if (!ifNotSet || this.options[name] === undefined) {\n        if (this.getOption(name) !== value) this.resolved = false;\n        this.options[name] = value;\n    }\n\n    return this;\n};\n\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n    if (!this.parsedOptions) {\n        this.parsedOptions = [];\n    }\n    var parsedOptions = this.parsedOptions;\n    if (propName) {\n        // If setting a sub property of an option then try to merge it\n        // with an existing option\n        var opt = parsedOptions.find(function (opt) {\n            return Object.prototype.hasOwnProperty.call(opt, name);\n        });\n        if (opt) {\n            // If we found an existing option - just merge the property value\n            // (If it's a feature, will just write over)\n            var newValue = opt[name];\n            util.setProperty(newValue, propName, value);\n        } else {\n            // otherwise, create a new option, set its property and add it to the list\n            opt = {};\n            opt[name] = util.setProperty({}, propName, value);\n            parsedOptions.push(opt);\n        }\n    } else {\n        // Always create a new option when setting the value of the option itself\n        var newOpt = {};\n        newOpt[name] = value;\n        parsedOptions.push(newOpt);\n    }\n\n    return this;\n};\n\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options)\n        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)\n            this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */\nReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className,\n        fullName  = this.fullName;\n    if (fullName.length)\n        return className + \" \" + fullName;\n    return className;\n};\n\n/**\n * Converts the edition this object is pinned to for JSON format.\n * @returns {string|undefined} The edition string for JSON representation\n */\nReflectionObject.prototype._editionToJSON = function _editionToJSON() {\n    if (!this._edition || this._edition === \"proto3\") {\n        // Avoid emitting proto3 since we need to default to it for backwards\n        // compatibility anyway.\n        return undefined;\n    }\n    return this._edition;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function(Root_) {\n    Root = Root_;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}