{"ast":null,"code":"\"use strict\";\n\nmodule.exports = encoder;\nvar Enum = require(\"./enum\"),\n  types = require(\"./types\"),\n  util = require(\"./util\");\n\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n  return field.delimited ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction encoder(mtype) {\n  /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n  var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")(\"if(!w)\")(\"w=Writer.create()\");\n  var i, ref;\n\n  // \"when a message is serialized its known fields should be written sequentially by field number\"\n  var fields = /* initializes */mtype.fieldsArray.slice().sort(util.compareFieldsById);\n  for (var i = 0; i < fields.length; ++i) {\n    var field = fields[i].resolve(),\n      index = mtype._fieldsArray.indexOf(field),\n      type = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n      wireType = types.basic[type];\n    ref = \"m\" + util.safeProp(field.name);\n\n    // Map fields\n    if (field.map) {\n      gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n      (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)(\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n      if (wireType === undefined) gen(\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n      else gen(\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n      gen(\"}\")(\"}\");\n\n      // Repeated fields\n    } else if (field.repeated) {\n      gen(\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n\n      // Packed repeated\n      if (field.packed && types.packed[type] !== undefined) {\n        gen(\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)(\"for(var i=0;i<%s.length;++i)\", ref)(\"w.%s(%s[i])\", type, ref)(\"w.ldelim()\");\n\n        // Non-packed\n      } else {\n        gen(\"for(var i=0;i<%s.length;++i)\", ref);\n        if (wireType === undefined) genTypePartial(gen, field, index, ref + \"[i]\");else gen(\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n      }\n      gen(\"}\");\n\n      // Non-repeated\n    } else {\n      if (field.optional) gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n      if (wireType === undefined) genTypePartial(gen, field, index, ref);else gen(\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n    }\n  }\n  return gen(\"return w\");\n  /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}","map":{"version":3,"names":["module","exports","encoder","Enum","require","types","util","genTypePartial","gen","field","fieldIndex","ref","delimited","id","mtype","codegen","name","i","fields","fieldsArray","slice","sort","compareFieldsById","length","resolve","index","_fieldsArray","indexOf","type","resolvedType","wireType","basic","safeProp","map","mapKey","keyType","undefined","repeated","packed","optional"],"sources":["/home/linux-1/projects/web-server-app/imx8mp-web-client/node_modules/protobufjs/src/encoder.js"],"sourcesContent":["\"use strict\";\nmodule.exports = encoder;\n\nvar Enum     = require(\"./enum\"),\n    types    = require(\"./types\"),\n    util     = require(\"./util\");\n\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n    return field.delimited\n        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\n        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\n    (\"if(!w)\")\n        (\"w=Writer.create()\");\n\n    var i, ref;\n\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n    for (var i = 0; i < fields.length; ++i) {\n        var field    = fields[i].resolve(),\n            index    = mtype._fieldsArray.indexOf(field),\n            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            wireType = types.basic[type];\n            ref      = \"m\" + util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) {\n            gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\n            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen\n            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen\n            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen\n        (\"}\")\n    (\"}\");\n\n            // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) { gen\n\n        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\n        (\"for(var i=0;i<%s.length;++i)\", ref)\n            (\"w.%s(%s[i])\", type, ref)\n        (\"w.ldelim()\");\n\n            // Non-packed\n            } else { gen\n\n        (\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined)\n            genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen\n            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n            } gen\n    (\"}\");\n\n        // Non-repeated\n        } else {\n            if (field.optional) gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n            if (wireType === undefined)\n        genTypePartial(gen, field, index, ref);\n            else gen\n        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n        }\n    }\n\n    return gen\n    (\"return w\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}